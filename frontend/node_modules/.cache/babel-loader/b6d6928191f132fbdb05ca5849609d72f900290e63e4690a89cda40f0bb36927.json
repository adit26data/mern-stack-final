{"ast":null,"code":"import _defineProperty from \"C:/Users/Adit/Desktop/mern-stack-final/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"C:/Users/Adit/Desktop/mern-stack-final/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/Adit/Desktop/mern-stack-final/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY } from '../../../colDef';\nimport { gridColumnsStateSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridColumnGroupsHeaderMaxDepthSelector } from '../columnGrouping/gridColumnGroupsSelector';\nexport var COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\nexport function computeFlexColumnsWidth(_ref) {\n  var initialFreeSpace = _ref.initialFreeSpace,\n    totalFlexUnits = _ref.totalFlexUnits,\n    flexColumns = _ref.flexColumns;\n  var flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: function freeze(field) {\n      var value = flexColumnsLookup.all[field];\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  };\n\n  // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n    var violationsLookup = {\n      min: {},\n      max: {}\n    };\n    var remainingFreeSpace = initialFreeSpace;\n    var flexUnits = totalFlexUnits;\n    var totalViolation = 0;\n\n    // 5b: Calculate the remaining free space\n    flexColumnsLookup.frozenFields.forEach(function (field) {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n    for (var i = 0; i < flexColumns.length; i += 1) {\n      var column = flexColumns[i];\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      // 5c: Distribute remaining free space proportional to the flex factors\n      var widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      var computedWidth = widthPerFlexUnit * column.flex;\n\n      // 5d: Fix min/max violations\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth: computedWidth,\n        flex: column.flex\n      };\n    }\n\n    // 5e: Freeze over-flexed items\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(function (field) {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(function (field) {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(function (_ref2) {\n        var field = _ref2.field;\n        flexColumnsLookup.freeze(field);\n      });\n    }\n\n    // 5f: Return to the start of this loop\n    loopOverFlexItems();\n  }\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\nexport var hydrateColumnsWidth = function hydrateColumnsWidth(rawState, viewportInnerWidth) {\n  var columnsLookup = {};\n  var totalFlexUnits = 0;\n  var widthAllocatedBeforeFlex = 0;\n  var flexColumns = [];\n\n  // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n  rawState.orderedFields.forEach(function (columnField) {\n    var newColumn = _extends({}, rawState.lookup[columnField]);\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      var computedWidth;\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n    columnsLookup[columnField] = newColumn;\n  });\n  var initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0);\n\n  // Allocate the remaining space to the flex columns\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    var computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace: initialFreeSpace,\n      totalFlexUnits: totalFlexUnits,\n      flexColumns: flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(function (field) {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\n\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\nexport var applyInitialState = function applyInitialState(columnsState, initialState) {\n  if (!initialState) {\n    return columnsState;\n  }\n  var _initialState$ordered = initialState.orderedFields,\n    orderedFields = _initialState$ordered === void 0 ? [] : _initialState$ordered,\n    _initialState$dimensi = initialState.dimensions,\n    dimensions = _initialState$dimensi === void 0 ? {} : _initialState$dimensi;\n  var columnsWithUpdatedDimensions = Object.keys(dimensions);\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n  var orderedFieldsLookup = {};\n  var cleanOrderedFields = [];\n  for (var i = 0; i < orderedFields.length; i += 1) {\n    var field = orderedFields[i];\n\n    // Ignores the fields in the initialState that matches no field on the current column state\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n  var newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [].concat(cleanOrderedFields, _toConsumableArray(columnsState.orderedFields.filter(function (field) {\n    return !orderedFieldsLookup[field];\n  })));\n  var newColumnLookup = _extends({}, columnsState.lookup);\n  var _loop = function _loop() {\n    var field = columnsWithUpdatedDimensions[_i];\n    var newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n    Object.entries(dimensions[field]).forEach(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        key = _ref4[0],\n        value = _ref4[1];\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  };\n  for (var _i = 0; _i < columnsWithUpdatedDimensions.length; _i += 1) {\n    _loop();\n  }\n  var newColumnsState = _extends({}, columnsState, {\n    orderedFields: newOrderedFields,\n    lookup: newColumnLookup\n  });\n  return newColumnsState;\n};\nexport var createColumnsState = function createColumnsState(_ref5) {\n  var apiRef = _ref5.apiRef,\n    columnsToUpsert = _ref5.columnsToUpsert,\n    initialState = _ref5.initialState,\n    columnTypes = _ref5.columnTypes,\n    _ref5$columnVisibilit = _ref5.columnVisibilityModel,\n    columnVisibilityModel = _ref5$columnVisibilit === void 0 ? gridColumnVisibilityModelSelector(apiRef) : _ref5$columnVisibilit,\n    _ref5$keepOnlyColumns = _ref5.keepOnlyColumnsToUpsert,\n    keepOnlyColumnsToUpsert = _ref5$keepOnlyColumns === void 0 ? false : _ref5$keepOnlyColumns;\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n  var isInsideStateInitializer = !apiRef.current.state.columns;\n  var columnsState;\n  if (isInsideStateInitializer) {\n    columnsState = {\n      orderedFields: [],\n      lookup: {},\n      columnVisibilityModel: columnVisibilityModel\n    };\n  } else {\n    var currentState = gridColumnsStateSelector(apiRef.current.state);\n    columnsState = {\n      orderedFields: keepOnlyColumnsToUpsert ? [] : _toConsumableArray(currentState.orderedFields),\n      lookup: _extends({}, currentState.lookup),\n      // Will be cleaned later if keepOnlyColumnsToUpsert=true\n      columnVisibilityModel: columnVisibilityModel\n    };\n  }\n  var columnsToKeep = {};\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsState.lookup).reduce(function (acc, key) {\n      return _extends({}, acc, _defineProperty({}, key, false));\n    }, {});\n  }\n  var columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(function (newColumn) {\n    var field = newColumn.field;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    var existingState = columnsState.lookup[field];\n    if (existingState == null) {\n      var colDef = columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n      if (newColumn.type && columnTypes[newColumn.type]) {\n        colDef = columnTypes[newColumn.type];\n      }\n      existingState = _extends({}, colDef, {\n        field: field,\n        hasBeenResized: false\n      });\n      columnsState.orderedFields.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsState.orderedFields.push(field);\n    }\n    var hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(function (key) {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsState.lookup[field] = _extends({}, existingState, newColumn, {\n      hasBeenResized: hasBeenResized\n    });\n  });\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsState.lookup).forEach(function (field) {\n      if (!columnsToKeep[field]) {\n        delete columnsState.lookup[field];\n      }\n    });\n  }\n  var columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsState);\n  var columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n  return hydrateColumnsWidth(columnsStateWithPortableColumns, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport var mergeColumnsState = function mergeColumnsState(columnsState) {\n  return function (state) {\n    return _extends({}, state, {\n      columns: columnsState\n    });\n  };\n};\nexport function getFirstNonSpannedColumnToRender(_ref6) {\n  var firstColumnToRender = _ref6.firstColumnToRender,\n    apiRef = _ref6.apiRef,\n    firstRowToRender = _ref6.firstRowToRender,\n    lastRowToRender = _ref6.lastRowToRender,\n    visibleRows = _ref6.visibleRows;\n  var firstNonSpannedColumnToRender = firstColumnToRender;\n  for (var i = firstRowToRender; i < lastRowToRender; i += 1) {\n    var row = visibleRows[i];\n    if (row) {\n      var rowId = visibleRows[i].id;\n      var cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n  return firstNonSpannedColumnToRender;\n}\nexport function getFirstColumnIndexToRender(_ref7) {\n  var firstColumnIndex = _ref7.firstColumnIndex,\n    minColumnIndex = _ref7.minColumnIndex,\n    columnBuffer = _ref7.columnBuffer,\n    firstRowToRender = _ref7.firstRowToRender,\n    lastRowToRender = _ref7.lastRowToRender,\n    apiRef = _ref7.apiRef,\n    visibleRows = _ref7.visibleRows;\n  var initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);\n  var firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef: apiRef,\n    firstRowToRender: firstRowToRender,\n    lastRowToRender: lastRowToRender,\n    visibleRows: visibleRows\n  });\n  return firstColumnToRender;\n}\nexport function getTotalHeaderHeight(apiRef, headerHeight) {\n  var densityFactor = gridDensityFactorSelector(apiRef);\n  var maxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef);\n  return Math.floor(headerHeight * densityFactor) * ((maxDepth != null ? maxDepth : 0) + 1);\n}","map":{"version":3,"names":["_extends","DEFAULT_GRID_COL_TYPE_KEY","gridColumnsStateSelector","gridColumnVisibilityModelSelector","clamp","gridDensityFactorSelector","gridColumnGroupsHeaderMaxDepthSelector","COLUMNS_DIMENSION_PROPERTIES","computeFlexColumnsWidth","_ref","initialFreeSpace","totalFlexUnits","flexColumns","flexColumnsLookup","all","frozenFields","freeze","field","value","frozen","push","loopOverFlexItems","length","violationsLookup","min","max","remainingFreeSpace","flexUnits","totalViolation","forEach","computedWidth","flex","i","column","widthPerFlexUnit","minWidth","maxWidth","Object","keys","_ref2","hydrateColumnsWidth","rawState","viewportInnerWidth","columnsLookup","widthAllocatedBeforeFlex","orderedFields","columnField","newColumn","lookup","columnVisibilityModel","width","Math","computedColumnWidths","applyInitialState","columnsState","initialState","_initialState$ordered","_initialState$dimensi","dimensions","columnsWithUpdatedDimensions","orderedFieldsLookup","cleanOrderedFields","newOrderedFields","concat","_toConsumableArray","filter","newColumnLookup","_loop","newColDef","hasBeenResized","entries","_ref3","_ref4","_slicedToArray","key","Infinity","newColumnsState","createColumnsState","_ref5","apiRef","columnsToUpsert","columnTypes","_ref5$columnVisibilit","_ref5$keepOnlyColumns","keepOnlyColumnsToUpsert","_apiRef$current$getRo","_apiRef$current$getRo2","_apiRef$current","_apiRef$current$getRo3","isInsideStateInitializer","current","state","columns","currentState","columnsToKeep","reduce","acc","_defineProperty","columnsToUpsertLookup","existingState","colDef","type","undefined","columnsStateWithPreProcessing","unstable_applyPipeProcessors","columnsStateWithPortableColumns","getRootDimensions","call","viewportInnerSize","mergeColumnsState","getFirstNonSpannedColumnToRender","_ref6","firstColumnToRender","firstRowToRender","lastRowToRender","visibleRows","firstNonSpannedColumnToRender","row","rowId","id","cellColSpanInfo","unstable_getCellColSpanInfo","spannedByColSpan","leftVisibleCellIndex","getFirstColumnIndexToRender","_ref7","firstColumnIndex","minColumnIndex","columnBuffer","initialFirstColumnToRender","getTotalHeaderHeight","headerHeight","densityFactor","maxDepth","floor"],"sources":["C:/Users/Adit/Desktop/mern-stack-final/frontend/node_modules/@mui/x-data-grid/hooks/features/columns/gridColumnsUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY } from '../../../colDef';\nimport { gridColumnsStateSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridColumnGroupsHeaderMaxDepthSelector } from '../columnGrouping/gridColumnGroupsSelector';\nexport const COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\nexport function computeFlexColumnsWidth({\n  initialFreeSpace,\n  totalFlexUnits,\n  flexColumns\n}) {\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  };\n\n  // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0;\n\n    // 5b: Calculate the remaining free space\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      // 5c: Distribute remaining free space proportional to the flex factors\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex;\n\n      // 5d: Fix min/max violations\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    }\n\n    // 5e: Freeze over-flexed items\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(({\n        field\n      }) => {\n        flexColumnsLookup.freeze(field);\n      });\n    }\n\n    // 5f: Return to the start of this loop\n    loopOverFlexItems();\n  }\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\nexport const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = [];\n\n  // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n  rawState.orderedFields.forEach(columnField => {\n    const newColumn = _extends({}, rawState.lookup[columnField]);\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      let computedWidth;\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n    columnsLookup[columnField] = newColumn;\n  });\n  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0);\n\n  // Allocate the remaining space to the flex columns\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\n\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\nexport const applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i];\n\n    // Ignores the fields in the initialState that matches no field on the current column state\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [...cleanOrderedFields, ...columnsState.orderedFields.filter(field => !orderedFieldsLookup[field])];\n  const newColumnLookup = _extends({}, columnsState.lookup);\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n    const newColDef = _extends({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n    Object.entries(dimensions[field]).forEach(([key, value]) => {\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  }\n  const newColumnsState = _extends({}, columnsState, {\n    orderedFields: newOrderedFields,\n    lookup: newColumnLookup\n  });\n  return newColumnsState;\n};\nexport const createColumnsState = ({\n  apiRef,\n  columnsToUpsert,\n  initialState,\n  columnTypes,\n  columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n  keepOnlyColumnsToUpsert = false\n}) => {\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsState;\n  if (isInsideStateInitializer) {\n    columnsState = {\n      orderedFields: [],\n      lookup: {},\n      columnVisibilityModel\n    };\n  } else {\n    const currentState = gridColumnsStateSelector(apiRef.current.state);\n    columnsState = {\n      orderedFields: keepOnlyColumnsToUpsert ? [] : [...currentState.orderedFields],\n      lookup: _extends({}, currentState.lookup),\n      // Will be cleaned later if keepOnlyColumnsToUpsert=true\n      columnVisibilityModel\n    };\n  }\n  let columnsToKeep = {};\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsState.lookup).reduce((acc, key) => _extends({}, acc, {\n      [key]: false\n    }), {});\n  }\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    const {\n      field\n    } = newColumn;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    let existingState = columnsState.lookup[field];\n    if (existingState == null) {\n      let colDef = columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n      if (newColumn.type && columnTypes[newColumn.type]) {\n        colDef = columnTypes[newColumn.type];\n      }\n      existingState = _extends({}, colDef, {\n        field,\n        hasBeenResized: false\n      });\n      columnsState.orderedFields.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsState.orderedFields.push(field);\n    }\n    let hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(key => {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsState.lookup[field] = _extends({}, existingState, newColumn, {\n      hasBeenResized\n    });\n  });\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsState.lookup).forEach(field => {\n      if (!columnsToKeep[field]) {\n        delete columnsState.lookup[field];\n      }\n    });\n  }\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsState);\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n  return hydrateColumnsWidth(columnsStateWithPortableColumns, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport const mergeColumnsState = columnsState => state => _extends({}, state, {\n  columns: columnsState\n});\nexport function getFirstNonSpannedColumnToRender({\n  firstColumnToRender,\n  apiRef,\n  firstRowToRender,\n  lastRowToRender,\n  visibleRows\n}) {\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n    const row = visibleRows[i];\n    if (row) {\n      const rowId = visibleRows[i].id;\n      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n  return firstNonSpannedColumnToRender;\n}\nexport function getFirstColumnIndexToRender({\n  firstColumnIndex,\n  minColumnIndex,\n  columnBuffer,\n  firstRowToRender,\n  lastRowToRender,\n  apiRef,\n  visibleRows\n}) {\n  const initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows\n  });\n  return firstColumnToRender;\n}\nexport function getTotalHeaderHeight(apiRef, headerHeight) {\n  const densityFactor = gridDensityFactorSelector(apiRef);\n  const maxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef);\n  return Math.floor(headerHeight * densityFactor) * ((maxDepth != null ? maxDepth : 0) + 1);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}