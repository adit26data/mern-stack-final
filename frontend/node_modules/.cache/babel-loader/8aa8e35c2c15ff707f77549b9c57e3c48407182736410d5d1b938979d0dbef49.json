{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) : typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) : (global = global || self, factory(global.swipeable = {}, global.react));\n})(this, function (exports, React) {\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () {\n              return e[k];\n            }\n          });\n        }\n      });\n    }\n    n['default'] = e;\n    return n;\n  }\n  var React__namespace = /*#__PURE__*/_interopNamespace(React);\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  var LEFT = \"Left\";\n  var RIGHT = \"Right\";\n  var UP = \"Up\";\n  var DOWN = \"Down\";\n  var defaultProps = {\n    delta: 10,\n    preventDefaultTouchmoveEvent: false,\n    rotationAngle: 0,\n    trackMouse: false,\n    trackTouch: true\n  };\n  var initialState = {\n    first: true,\n    initial: [0, 0],\n    start: 0,\n    swiping: false,\n    xy: [0, 0]\n  };\n  var mouseMove = \"mousemove\";\n  var mouseUp = \"mouseup\";\n  var touchEnd = \"touchend\";\n  var touchMove = \"touchmove\";\n  var touchStart = \"touchstart\";\n  function getDirection(absX, absY, deltaX, deltaY) {\n    if (absX > absY) {\n      if (deltaX > 0) {\n        return RIGHT;\n      }\n      return LEFT;\n    } else if (deltaY > 0) {\n      return DOWN;\n    }\n    return UP;\n  }\n  function rotateXYByAngle(pos, angle) {\n    if (angle === 0) return pos;\n    var angleInRadians = Math.PI / 180 * angle;\n    var x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n    var y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n    return [x, y];\n  }\n  function getHandlers(set, handlerProps) {\n    var onStart = function onStart(event) {\n      if (event && \"touches\" in event && event.touches.length > 1) return;\n      set(function (state, props) {\n        if (props.trackMouse) {\n          document.addEventListener(mouseMove, onMove);\n          document.addEventListener(mouseUp, onUp);\n        }\n        var _ref = \"touches\" in event ? event.touches[0] : event,\n          clientX = _ref.clientX,\n          clientY = _ref.clientY;\n        var xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n        return _extends({}, state, initialState, {\n          initial: [].concat(xy),\n          xy: xy,\n          start: event.timeStamp || 0\n        });\n      });\n    };\n    var onMove = function onMove(event) {\n      set(function (state, props) {\n        if (\"touches\" in event && event.touches.length > 1) {\n          return state;\n        }\n        var _ref2 = \"touches\" in event ? event.touches[0] : event,\n          clientX = _ref2.clientX,\n          clientY = _ref2.clientY;\n        var _rotateXYByAngle = rotateXYByAngle([clientX, clientY], props.rotationAngle),\n          x = _rotateXYByAngle[0],\n          y = _rotateXYByAngle[1];\n        var deltaX = x - state.xy[0];\n        var deltaY = y - state.xy[1];\n        var absX = Math.abs(deltaX);\n        var absY = Math.abs(deltaY);\n        var time = (event.timeStamp || 0) - state.start;\n        var velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n        var vxvy = [deltaX / (time || 1), deltaY / (time || 1)];\n        var dir = getDirection(absX, absY, deltaX, deltaY);\n        var delta = typeof props.delta === \"number\" ? props.delta : props.delta[dir.toLowerCase()] || defaultProps.delta;\n        if (absX < delta && absY < delta && !state.swiping) return state;\n        var eventData = {\n          absX: absX,\n          absY: absY,\n          deltaX: deltaX,\n          deltaY: deltaY,\n          dir: dir,\n          event: event,\n          first: state.first,\n          initial: state.initial,\n          velocity: velocity,\n          vxvy: vxvy\n        };\n        eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n        props.onSwiping && props.onSwiping(eventData);\n        var cancelablePageSwipe = false;\n        if (props.onSwiping || props.onSwiped || \"onSwiped\" + dir in props) {\n          cancelablePageSwipe = true;\n        }\n        if (cancelablePageSwipe && props.preventDefaultTouchmoveEvent && props.trackTouch && event.cancelable) event.preventDefault();\n        return _extends({}, state, {\n          first: false,\n          eventData: eventData,\n          swiping: true\n        });\n      });\n    };\n    var onEnd = function onEnd(event) {\n      set(function (state, props) {\n        var eventData;\n        if (state.swiping && state.eventData) {\n          eventData = _extends({}, state.eventData, {\n            event: event\n          });\n          props.onSwiped && props.onSwiped(eventData);\n          var onSwipedDir = props[\"onSwiped\" + eventData.dir];\n          onSwipedDir && onSwipedDir(eventData);\n        } else {\n          props.onTap && props.onTap({\n            event: event\n          });\n        }\n        return _extends({}, state, initialState, {\n          eventData: eventData\n        });\n      });\n    };\n    var cleanUpMouse = function cleanUpMouse() {\n      document.removeEventListener(mouseMove, onMove);\n      document.removeEventListener(mouseUp, onUp);\n    };\n    var onUp = function onUp(e) {\n      cleanUpMouse();\n      onEnd(e);\n    };\n    var attachTouch = function attachTouch(el, passive) {\n      var cleanup = function cleanup() {};\n      if (el && el.addEventListener) {\n        var tls = [[touchStart, onStart], [touchMove, onMove], [touchEnd, onEnd]];\n        tls.forEach(function (_ref3) {\n          var e = _ref3[0],\n            h = _ref3[1];\n          return el.addEventListener(e, h, {\n            passive: passive\n          });\n        });\n        cleanup = function cleanup() {\n          return tls.forEach(function (_ref4) {\n            var e = _ref4[0],\n              h = _ref4[1];\n            return el.removeEventListener(e, h);\n          });\n        };\n      }\n      return cleanup;\n    };\n    var onRef = function onRef(el) {\n      if (el === null) return;\n      set(function (state, props) {\n        if (state.el === el) return state;\n        var addState = {};\n        if (state.el && state.el !== el && state.cleanUpTouch) {\n          state.cleanUpTouch();\n          addState.cleanUpTouch = void 0;\n        }\n        if (props.trackTouch && el) {\n          addState.cleanUpTouch = attachTouch(el, !props.preventDefaultTouchmoveEvent);\n        }\n        return _extends({}, state, {\n          el: el\n        }, addState);\n      });\n    };\n    var output = {\n      ref: onRef\n    };\n    if (handlerProps.trackMouse) {\n      output.onMouseDown = onStart;\n    }\n    return [output, attachTouch];\n  }\n  function updateTransientState(state, props, attachTouch) {\n    var addState = {};\n    if (!props.trackTouch && state.cleanUpTouch) {\n      state.cleanUpTouch();\n      addState.cleanUpTouch = void 0;\n    } else if (props.trackTouch && !state.cleanUpTouch) {\n      if (state.el) {\n        addState.cleanUpTouch = attachTouch(state.el, !props.preventDefaultTouchmoveEvent);\n      }\n    }\n    return _extends({}, state, addState);\n  }\n  function useSwipeable(options) {\n    var trackMouse = options.trackMouse;\n    var transientState = React__namespace.useRef(_extends({}, initialState));\n    var transientProps = React__namespace.useRef(_extends({}, defaultProps));\n    transientProps.current = _extends({}, defaultProps, options, {\n      delta: options.delta === void 0 ? defaultProps.delta : options.delta,\n      rotationAngle: options.rotationAngle === void 0 ? defaultProps.rotationAngle : options.rotationAngle,\n      trackTouch: options.trackTouch === void 0 ? defaultProps.trackTouch : options.trackTouch\n    });\n    var _React$useMemo = React__namespace.useMemo(function () {\n        return getHandlers(function (stateSetter) {\n          return transientState.current = stateSetter(transientState.current, transientProps.current);\n        }, {\n          trackMouse: trackMouse\n        });\n      }, [trackMouse]),\n      handlers = _React$useMemo[0],\n      attachTouch = _React$useMemo[1];\n    transientState.current = updateTransientState(transientState.current, transientProps.current, attachTouch);\n    return handlers;\n  }\n  exports.DOWN = DOWN;\n  exports.LEFT = LEFT;\n  exports.RIGHT = RIGHT;\n  exports.UP = UP;\n  exports.useSwipeable = useSwipeable;\n});","map":{"version":3,"names":["LEFT","RIGHT","UP","DOWN","defaultProps","delta","preventDefaultTouchmoveEvent","rotationAngle","trackMouse","trackTouch","initialState","first","initial","start","swiping","xy","mouseMove","mouseUp","touchEnd","touchMove","touchStart","getDirection","absX","absY","deltaX","deltaY","rotateXYByAngle","pos","angle","angleInRadians","Math","PI","x","cos","sin","y","getHandlers","set","handlerProps","onStart","event","touches","length","state","props","document","addEventListener","onMove","onUp","clientX","_ref","clientY","_extends","concat","timeStamp","_ref2","_rotateXYByAngle","abs","time","velocity","sqrt","vxvy","dir","toLowerCase","eventData","onSwipeStart","onSwiping","cancelablePageSwipe","onSwiped","cancelable","preventDefault","onEnd","onSwipedDir","onTap","cleanUpMouse","removeEventListener","e","attachTouch","el","passive","cleanup","tls","forEach","_ref3","h","_ref4","onRef","addState","cleanUpTouch","output","ref","onMouseDown","updateTransientState","useSwipeable","options","transientState","React__namespace","useRef","transientProps","current","useMemo","stateSetter","handlers","_React$useMemo"],"sources":["C:\\Users\\Adit\\Desktop\\mern-stack-final\\frontend\\node_modules\\react-swipeable\\src\\types.ts","C:\\Users\\Adit\\Desktop\\mern-stack-final\\frontend\\node_modules\\react-swipeable\\src\\index.ts"],"sourcesContent":["import * as React from \"react\";\n\nexport const LEFT = \"Left\";\nexport const RIGHT = \"Right\";\nexport const UP = \"Up\";\nexport const DOWN = \"Down\";\nexport type HandledEvents = React.MouseEvent | TouchEvent | MouseEvent;\nexport type Vector2 = [number, number];\nexport type SwipeDirections =\n  | typeof LEFT\n  | typeof RIGHT\n  | typeof UP\n  | typeof DOWN;\nexport interface SwipeEventData {\n  absX: number;\n  absY: number;\n  deltaX: number;\n  deltaY: number;\n  dir: SwipeDirections;\n  event: HandledEvents;\n  first: boolean;\n  initial: Vector2;\n  velocity: number;\n  vxvy: Vector2;\n}\n\nexport type SwipeCallback = (eventData: SwipeEventData) => void;\nexport type TapCallback = ({ event }: { event: HandledEvents }) => void;\n\nexport type SwipeableCallbacks = {\n  // Event handler/callbacks\n  onSwipeStart: SwipeCallback;\n  onSwiped: SwipeCallback;\n  onSwipedDown: SwipeCallback;\n  onSwipedLeft: SwipeCallback;\n  onSwipedRight: SwipeCallback;\n  onSwipedUp: SwipeCallback;\n  onSwiping: SwipeCallback;\n  onTap: TapCallback;\n};\n\n// Configuration Options\nexport type ConfigurationOptionDelta =\n  | number\n  | { [key in Lowercase<SwipeDirections>]?: number };\nexport interface ConfigurationOptions {\n  delta: ConfigurationOptionDelta;\n  preventDefaultTouchmoveEvent: boolean;\n  rotationAngle: number;\n  trackMouse: boolean;\n  trackTouch: boolean;\n}\n\nexport type SwipeableProps = Partial<SwipeableCallbacks & ConfigurationOptions>;\n\nexport type SwipeablePropsWithDefaultOptions = Partial<SwipeableCallbacks> &\n  ConfigurationOptions;\n\nexport interface SwipeableHandlers {\n  ref(element: HTMLElement | null): void;\n  onMouseDown?(event: React.MouseEvent): void;\n}\n\nexport type SwipeableState = {\n  cleanUpTouch?: () => void;\n  el?: HTMLElement;\n  eventData?: SwipeEventData;\n  first: boolean;\n  initial: Vector2;\n  start: number;\n  swiping: boolean;\n  xy: Vector2;\n};\n\nexport type StateSetter = (\n  state: SwipeableState,\n  props: SwipeablePropsWithDefaultOptions\n) => SwipeableState;\nexport type Setter = (stateSetter: StateSetter) => void;\nexport type AttachTouch = (el: HTMLElement, passive: boolean) => () => void;\n","/* global document */\nimport * as React from \"react\";\nimport {\n  AttachTouch,\n  SwipeDirections,\n  DOWN,\n  SwipeEventData,\n  HandledEvents,\n  LEFT,\n  RIGHT,\n  Setter,\n  ConfigurationOptions,\n  SwipeableCallbacks,\n  SwipeableHandlers,\n  SwipeableProps,\n  SwipeablePropsWithDefaultOptions,\n  SwipeableState,\n  SwipeCallback,\n  TapCallback,\n  UP,\n  Vector2,\n} from \"./types\";\n\nexport {\n  LEFT,\n  RIGHT,\n  UP,\n  DOWN,\n  SwipeDirections,\n  SwipeEventData,\n  SwipeCallback,\n  TapCallback,\n  SwipeableHandlers,\n  SwipeableProps,\n  Vector2,\n};\n\nconst defaultProps: ConfigurationOptions = {\n  delta: 10,\n  preventDefaultTouchmoveEvent: false,\n  rotationAngle: 0,\n  trackMouse: false,\n  trackTouch: true,\n};\nconst initialState: SwipeableState = {\n  first: true,\n  initial: [0, 0],\n  start: 0,\n  swiping: false,\n  xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\n\nfunction getDirection(\n  absX: number,\n  absY: number,\n  deltaX: number,\n  deltaY: number\n): SwipeDirections {\n  if (absX > absY) {\n    if (deltaX > 0) {\n      return RIGHT;\n    }\n    return LEFT;\n  } else if (deltaY > 0) {\n    return DOWN;\n  }\n  return UP;\n}\n\nfunction rotateXYByAngle(pos: Vector2, angle: number): Vector2 {\n  if (angle === 0) return pos;\n  const angleInRadians = (Math.PI / 180) * angle;\n  const x =\n    pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n  const y =\n    pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n  return [x, y];\n}\n\nfunction getHandlers(\n  set: Setter,\n  handlerProps: { trackMouse: boolean | undefined }\n): [\n  {\n    ref: (element: HTMLElement | null) => void;\n    onMouseDown?: (event: React.MouseEvent) => void;\n  },\n  AttachTouch\n] {\n  const onStart = (event: HandledEvents) => {\n    // if more than a single touch don't track, for now...\n    if (event && \"touches\" in event && event.touches.length > 1) return;\n\n    set((state, props) => {\n      // setup mouse listeners on document to track swipe since swipe can leave container\n      if (props.trackMouse) {\n        document.addEventListener(mouseMove, onMove);\n        document.addEventListener(mouseUp, onUp);\n      }\n      const { clientX, clientY } =\n        \"touches\" in event ? event.touches[0] : event;\n      const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      return {\n        ...state,\n        ...initialState,\n        initial: [...xy],\n        xy,\n        start: event.timeStamp || 0,\n      };\n    });\n  };\n\n  const onMove = (event: HandledEvents) => {\n    set((state, props) => {\n      // Discount a swipe if additional touches are present after\n      // a swipe has started.\n      if (\"touches\" in event && event.touches.length > 1) {\n        return state;\n      }\n      const { clientX, clientY } =\n        \"touches\" in event ? event.touches[0] : event;\n      const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      const deltaX = x - state.xy[0];\n      const deltaY = y - state.xy[1];\n      const absX = Math.abs(deltaX);\n      const absY = Math.abs(deltaY);\n      const time = (event.timeStamp || 0) - state.start;\n      const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n      const vxvy: Vector2 = [deltaX / (time || 1), deltaY / (time || 1)];\n\n      const dir = getDirection(absX, absY, deltaX, deltaY);\n\n      // if swipe is under delta and we have not started to track a swipe: skip update\n      const delta =\n        typeof props.delta === \"number\"\n          ? props.delta\n          : props.delta[dir.toLowerCase() as Lowercase<SwipeDirections>] ||\n            defaultProps.delta;\n      if (absX < delta && absY < delta && !state.swiping) return state;\n\n      const eventData = {\n        absX,\n        absY,\n        deltaX,\n        deltaY,\n        dir,\n        event,\n        first: state.first,\n        initial: state.initial,\n        velocity,\n        vxvy,\n      };\n\n      // call onSwipeStart if present and is first swipe event\n      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n\n      // Call onSwiping if present\n      props.onSwiping && props.onSwiping(eventData);\n\n      // track if a swipe is cancelable(handler for swiping or swiped(dir) exists)\n      // so we can call preventDefault if needed\n      let cancelablePageSwipe = false;\n      if (props.onSwiping || props.onSwiped || `onSwiped${dir}` in props) {\n        cancelablePageSwipe = true;\n      }\n\n      if (\n        cancelablePageSwipe &&\n        props.preventDefaultTouchmoveEvent &&\n        props.trackTouch &&\n        event.cancelable\n      )\n        event.preventDefault();\n\n      return {\n        ...state,\n        // first is now always false\n        first: false,\n        eventData,\n        swiping: true,\n      };\n    });\n  };\n\n  const onEnd = (event: HandledEvents) => {\n    set((state, props) => {\n      let eventData: SwipeEventData | undefined;\n      if (state.swiping && state.eventData) {\n        eventData = { ...state.eventData, event };\n        props.onSwiped && props.onSwiped(eventData);\n\n        const onSwipedDir =\n          props[`onSwiped${eventData.dir}` as keyof SwipeableCallbacks];\n        onSwipedDir && onSwipedDir(eventData);\n      } else {\n        props.onTap && props.onTap({ event });\n      }\n      return { ...state, ...initialState, eventData };\n    });\n  };\n\n  const cleanUpMouse = () => {\n    // safe to just call removeEventListener\n    document.removeEventListener(mouseMove, onMove);\n    document.removeEventListener(mouseUp, onUp);\n  };\n\n  const onUp = (e: HandledEvents) => {\n    cleanUpMouse();\n    onEnd(e);\n  };\n\n  /**\n   * Switch of \"passive\" property for now.\n   * When `preventDefaultTouchmoveEvent` is:\n   * - true => { passive: false }\n   * - false => { passive: true }\n   *\n   * Could take entire `addEventListener` options object as a param later?\n   */\n  const attachTouch: AttachTouch = (el, passive) => {\n    let cleanup = () => {};\n    if (el && el.addEventListener) {\n      // attach touch event listeners and handlers\n      const tls: [\n        typeof touchStart | typeof touchMove | typeof touchEnd,\n        (e: HandledEvents) => void\n      ][] = [\n        [touchStart, onStart],\n        [touchMove, onMove],\n        [touchEnd, onEnd],\n      ];\n      tls.forEach(([e, h]) => el.addEventListener(e, h, { passive }));\n      // return properly scoped cleanup method for removing listeners, options not required\n      cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n    }\n    return cleanup;\n  };\n\n  const onRef = (el: HTMLElement | null) => {\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n    // ignore null here\n    if (el === null) return;\n    set((state, props) => {\n      // if the same DOM el as previous just return state\n      if (state.el === el) return state;\n\n      const addState: { cleanUpTouch?: () => void } = {};\n      // if new DOM el clean up old DOM and reset cleanUpTouch\n      if (state.el && state.el !== el && state.cleanUpTouch) {\n        state.cleanUpTouch();\n        addState.cleanUpTouch = void 0;\n      }\n      // only attach if we want to track touch\n      if (props.trackTouch && el) {\n        addState.cleanUpTouch = attachTouch(\n          el,\n          !props.preventDefaultTouchmoveEvent\n        );\n      }\n\n      // store event attached DOM el for comparison, clean up, and re-attachment\n      return { ...state, el, ...addState };\n    });\n  };\n\n  // set ref callback to attach touch event listeners\n  const output: { ref: typeof onRef; onMouseDown?: typeof onStart } = {\n    ref: onRef,\n  };\n\n  // if track mouse attach mouse down listener\n  if (handlerProps.trackMouse) {\n    output.onMouseDown = onStart;\n  }\n\n  return [output, attachTouch];\n}\n\nfunction updateTransientState(\n  state: SwipeableState,\n  props: SwipeableProps,\n  attachTouch: AttachTouch\n) {\n  const addState: { cleanUpTouch?(): void } = {};\n  // clean up touch handlers if no longer tracking touches\n  if (!props.trackTouch && state.cleanUpTouch) {\n    state.cleanUpTouch();\n    addState.cleanUpTouch = void 0;\n  } else if (props.trackTouch && !state.cleanUpTouch) {\n    // attach/re-attach touch handlers\n    if (state.el) {\n      addState.cleanUpTouch = attachTouch(\n        state.el,\n        !props.preventDefaultTouchmoveEvent\n      );\n    }\n  }\n  return { ...state, ...addState };\n}\n\nexport function useSwipeable(options: SwipeableProps): SwipeableHandlers {\n  const { trackMouse } = options;\n  const transientState = React.useRef({ ...initialState });\n  const transientProps = React.useRef<SwipeablePropsWithDefaultOptions>({\n    ...defaultProps,\n  });\n  transientProps.current = {\n    ...defaultProps,\n    ...options,\n    // Force defaults for config properties\n    delta: options.delta === void 0 ? defaultProps.delta : options.delta,\n    rotationAngle:\n      options.rotationAngle === void 0\n        ? defaultProps.rotationAngle\n        : options.rotationAngle,\n    trackTouch:\n      options.trackTouch === void 0\n        ? defaultProps.trackTouch\n        : options.trackTouch,\n  };\n\n  const [handlers, attachTouch] = React.useMemo(\n    () =>\n      getHandlers(\n        (stateSetter) =>\n          (transientState.current = stateSetter(\n            transientState.current,\n            transientProps.current\n          )),\n        { trackMouse }\n      ),\n    [trackMouse]\n  );\n\n  transientState.current = updateTransientState(\n    transientState.current,\n    transientProps.current,\n    attachTouch\n  );\n\n  return handlers;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}