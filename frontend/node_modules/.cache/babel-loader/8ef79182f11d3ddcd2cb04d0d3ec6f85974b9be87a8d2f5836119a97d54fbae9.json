{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Adit/Desktop/mern-stack-final/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { isLeaf } from '../../../models/gridColumnGrouping';\nimport { isDeepEqual } from '../../../utils/utils';\n// This is the recurrence function that help writing `unwrapGroupingColumnModel()`\nvar recurrentUnwrapGroupingColumnModel = function recurrentUnwrapGroupingColumnModel(columnGroupNode, parents, unwrappedGroupingModelToComplete) {\n  if (isLeaf(columnGroupNode)) {\n    if (unwrappedGroupingModelToComplete[columnGroupNode.field] !== undefined) {\n      throw new Error([\"MUI: columnGroupingModel contains duplicated field\", \"column field \".concat(columnGroupNode.field, \" occurs two times in the grouping model:\"), \"- \".concat(unwrappedGroupingModelToComplete[columnGroupNode.field].join(' > ')), \"- \".concat(parents.join(' > '))].join('\\n'));\n    }\n    unwrappedGroupingModelToComplete[columnGroupNode.field] = parents;\n    return;\n  }\n  var groupId = columnGroupNode.groupId,\n    children = columnGroupNode.children;\n  children.forEach(function (child) {\n    recurrentUnwrapGroupingColumnModel(child, [].concat(_toConsumableArray(parents), [groupId]), unwrappedGroupingModelToComplete);\n  });\n};\n\n/**\n * This is a function that provide for each column the array of its parents.\n * Parents are ordered from the root to the leaf.\n * @param columnGroupingModel The model such as provided in DataGrid props\n * @returns An object `{[field]: groupIds}` where `groupIds` is the parents of the column `field`\n */\nexport var unwrapGroupingColumnModel = function unwrapGroupingColumnModel(columnGroupingModel) {\n  if (!columnGroupingModel) {\n    return {};\n  }\n  var unwrappedSubTree = {};\n  columnGroupingModel.forEach(function (columnGroupNode) {\n    recurrentUnwrapGroupingColumnModel(columnGroupNode, [], unwrappedSubTree);\n  });\n  return unwrappedSubTree;\n};\nexport var getColumnGroupsHeaderStructure = function getColumnGroupsHeaderStructure(orderedColumns, unwrappedGroupingModel) {\n  var getParents = function getParents(field) {\n    var _unwrappedGroupingMod;\n    return (_unwrappedGroupingMod = unwrappedGroupingModel[field]) != null ? _unwrappedGroupingMod : [];\n  };\n  var groupingHeaderStructure = [];\n  var maxDepth = Math.max.apply(Math, _toConsumableArray(orderedColumns.map(function (field) {\n    return getParents(field).length;\n  })));\n  var haveSameParents = function haveSameParents(field1, field2, depth) {\n    return isDeepEqual(getParents(field1).slice(0, depth + 1), getParents(field2).slice(0, depth + 1));\n  };\n  var _loop = function _loop(depth) {\n    var depthStructure = orderedColumns.reduce(function (structure, newField) {\n      var _getParents$depth;\n      var groupId = (_getParents$depth = getParents(newField)[depth]) != null ? _getParents$depth : null;\n      if (structure.length === 0) {\n        return [{\n          columnFields: [newField],\n          groupId: groupId\n        }];\n      }\n      var lastGroup = structure[structure.length - 1];\n      var prevField = lastGroup.columnFields[lastGroup.columnFields.length - 1];\n      var prevGroupId = lastGroup.groupId;\n      if (prevGroupId !== groupId || !haveSameParents(prevField, newField, depth)) {\n        // It's a new group\n        return [].concat(_toConsumableArray(structure), [{\n          columnFields: [newField],\n          groupId: groupId\n        }]);\n      }\n\n      // It extends the previous group\n      return [].concat(_toConsumableArray(structure.slice(0, structure.length - 1)), [{\n        columnFields: [].concat(_toConsumableArray(lastGroup.columnFields), [newField]),\n        groupId: groupId\n      }]);\n    }, []);\n    groupingHeaderStructure.push(depthStructure);\n  };\n  for (var depth = 0; depth < maxDepth; depth += 1) {\n    _loop(depth);\n  }\n  return groupingHeaderStructure;\n};","map":{"version":3,"names":["isLeaf","isDeepEqual","recurrentUnwrapGroupingColumnModel","columnGroupNode","parents","unwrappedGroupingModelToComplete","field","undefined","Error","concat","join","groupId","children","forEach","child","_toConsumableArray","unwrapGroupingColumnModel","columnGroupingModel","unwrappedSubTree","getColumnGroupsHeaderStructure","orderedColumns","unwrappedGroupingModel","getParents","_unwrappedGroupingMod","groupingHeaderStructure","maxDepth","Math","max","apply","map","length","haveSameParents","field1","field2","depth","slice","_loop","depthStructure","reduce","structure","newField","_getParents$depth","columnFields","lastGroup","prevField","prevGroupId","push"],"sources":["C:/Users/Adit/Desktop/mern-stack-final/frontend/node_modules/@mui/x-data-grid/hooks/features/columnGrouping/gridColumnGroupsUtils.js"],"sourcesContent":["import { isLeaf } from '../../../models/gridColumnGrouping';\nimport { isDeepEqual } from '../../../utils/utils';\n// This is the recurrence function that help writing `unwrapGroupingColumnModel()`\nconst recurrentUnwrapGroupingColumnModel = (columnGroupNode, parents, unwrappedGroupingModelToComplete) => {\n  if (isLeaf(columnGroupNode)) {\n    if (unwrappedGroupingModelToComplete[columnGroupNode.field] !== undefined) {\n      throw new Error([`MUI: columnGroupingModel contains duplicated field`, `column field ${columnGroupNode.field} occurs two times in the grouping model:`, `- ${unwrappedGroupingModelToComplete[columnGroupNode.field].join(' > ')}`, `- ${parents.join(' > ')}`].join('\\n'));\n    }\n    unwrappedGroupingModelToComplete[columnGroupNode.field] = parents;\n    return;\n  }\n  const {\n    groupId,\n    children\n  } = columnGroupNode;\n  children.forEach(child => {\n    recurrentUnwrapGroupingColumnModel(child, [...parents, groupId], unwrappedGroupingModelToComplete);\n  });\n};\n\n/**\n * This is a function that provide for each column the array of its parents.\n * Parents are ordered from the root to the leaf.\n * @param columnGroupingModel The model such as provided in DataGrid props\n * @returns An object `{[field]: groupIds}` where `groupIds` is the parents of the column `field`\n */\nexport const unwrapGroupingColumnModel = columnGroupingModel => {\n  if (!columnGroupingModel) {\n    return {};\n  }\n  const unwrappedSubTree = {};\n  columnGroupingModel.forEach(columnGroupNode => {\n    recurrentUnwrapGroupingColumnModel(columnGroupNode, [], unwrappedSubTree);\n  });\n  return unwrappedSubTree;\n};\nexport const getColumnGroupsHeaderStructure = (orderedColumns, unwrappedGroupingModel) => {\n  const getParents = field => {\n    var _unwrappedGroupingMod;\n    return (_unwrappedGroupingMod = unwrappedGroupingModel[field]) != null ? _unwrappedGroupingMod : [];\n  };\n  const groupingHeaderStructure = [];\n  const maxDepth = Math.max(...orderedColumns.map(field => getParents(field).length));\n  const haveSameParents = (field1, field2, depth) => isDeepEqual(getParents(field1).slice(0, depth + 1), getParents(field2).slice(0, depth + 1));\n  for (let depth = 0; depth < maxDepth; depth += 1) {\n    const depthStructure = orderedColumns.reduce((structure, newField) => {\n      var _getParents$depth;\n      const groupId = (_getParents$depth = getParents(newField)[depth]) != null ? _getParents$depth : null;\n      if (structure.length === 0) {\n        return [{\n          columnFields: [newField],\n          groupId\n        }];\n      }\n      const lastGroup = structure[structure.length - 1];\n      const prevField = lastGroup.columnFields[lastGroup.columnFields.length - 1];\n      const prevGroupId = lastGroup.groupId;\n      if (prevGroupId !== groupId || !haveSameParents(prevField, newField, depth)) {\n        // It's a new group\n        return [...structure, {\n          columnFields: [newField],\n          groupId\n        }];\n      }\n\n      // It extends the previous group\n      return [...structure.slice(0, structure.length - 1), {\n        columnFields: [...lastGroup.columnFields, newField],\n        groupId\n      }];\n    }, []);\n    groupingHeaderStructure.push(depthStructure);\n  }\n  return groupingHeaderStructure;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}