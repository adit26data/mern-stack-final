{"ast":null,"code":"import * as React from 'react';\nimport { useGridApiOptionHandler, useGridNativeEventListener } from '../../utils';\nimport { gridFocusCellSelector } from '../focus/gridFocusStateSelector';\nimport { serializeCellValue } from '../export/serializers/csvSerializer';\nfunction writeToClipboardPolyfill(data) {\n  var span = document.createElement('span');\n  span.style.whiteSpace = 'pre';\n  span.style.userSelect = 'all';\n  span.style.opacity = '0px';\n  span.textContent = data;\n  document.body.appendChild(span);\n  var range = document.createRange();\n  range.selectNode(span);\n  var selection = window.getSelection();\n  selection.removeAllRanges();\n  selection.addRange(range);\n  try {\n    document.execCommand('copy');\n  } finally {\n    document.body.removeChild(span);\n  }\n}\nfunction copyToClipboard(data) {\n  if (navigator.clipboard) {\n    navigator.clipboard.writeText(data).catch(function () {\n      writeToClipboardPolyfill(data);\n    });\n  } else {\n    writeToClipboardPolyfill(data);\n  }\n}\nfunction hasNativeSelection(element) {\n  var _window$getSelection;\n  // When getSelection is called on an <iframe> that is not displayed Firefox will return null.\n  if ((_window$getSelection = window.getSelection()) != null && _window$getSelection.toString()) {\n    return true;\n  }\n\n  // window.getSelection() returns an empty string in Firefox for selections inside a form element.\n  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=85686.\n  // Instead, we can use element.selectionStart that is only defined on form elements.\n  if (element && (element.selectionEnd || 0) - (element.selectionStart || 0) > 0) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @requires useGridCsvExport (method)\n * @requires useGridSelection (method)\n */\nexport var useGridClipboard = function useGridClipboard(apiRef, props) {\n  var ignoreValueFormatterProp = props.unstable_ignoreValueFormatterDuringExport;\n  var ignoreValueFormatter = (typeof ignoreValueFormatterProp === 'object' ? ignoreValueFormatterProp == null ? void 0 : ignoreValueFormatterProp.clipboardExport : ignoreValueFormatterProp) || false;\n  var clipboardCopyCellDelimiter = props.clipboardCopyCellDelimiter;\n  var handleCopy = React.useCallback(function (event) {\n    var isModifierKeyPressed = event.ctrlKey || event.metaKey;\n    // event.code === 'KeyC' is not enough as event.code assume a QWERTY keyboard layout which would\n    // be wrong with a Dvorak keyboard (as if pressing J).\n    if (String.fromCharCode(event.keyCode) !== 'C' || !isModifierKeyPressed) {\n      return;\n    }\n\n    // Do nothing if there's a native selection\n    if (hasNativeSelection(event.target)) {\n      return;\n    }\n    var textToCopy = '';\n    var selectedRows = apiRef.current.getSelectedRows();\n    if (selectedRows.size > 0) {\n      textToCopy = apiRef.current.getDataAsCsv({\n        includeHeaders: false,\n        // TODO: make it configurable\n        delimiter: clipboardCopyCellDelimiter\n      });\n    } else {\n      var focusedCell = gridFocusCellSelector(apiRef);\n      if (focusedCell) {\n        var cellParams = apiRef.current.getCellParams(focusedCell.id, focusedCell.field);\n        textToCopy = serializeCellValue(cellParams, {\n          delimiterCharacter: clipboardCopyCellDelimiter,\n          ignoreValueFormatter: ignoreValueFormatter\n        });\n      }\n    }\n    textToCopy = apiRef.current.unstable_applyPipeProcessors('clipboardCopy', textToCopy);\n    if (textToCopy) {\n      copyToClipboard(textToCopy);\n      apiRef.current.publishEvent('clipboardCopy', textToCopy);\n    }\n  }, [apiRef, ignoreValueFormatter, clipboardCopyCellDelimiter]);\n  useGridNativeEventListener(apiRef, apiRef.current.rootElementRef, 'keydown', handleCopy);\n  useGridApiOptionHandler(apiRef, 'clipboardCopy', props.onClipboardCopy);\n};","map":{"version":3,"names":["React","useGridApiOptionHandler","useGridNativeEventListener","gridFocusCellSelector","serializeCellValue","writeToClipboardPolyfill","data","span","document","createElement","style","whiteSpace","userSelect","opacity","textContent","body","appendChild","range","createRange","selectNode","selection","window","getSelection","removeAllRanges","addRange","execCommand","removeChild","copyToClipboard","navigator","clipboard","writeText","catch","hasNativeSelection","element","_window$getSelection","toString","selectionEnd","selectionStart","useGridClipboard","apiRef","props","ignoreValueFormatterProp","unstable_ignoreValueFormatterDuringExport","ignoreValueFormatter","clipboardExport","clipboardCopyCellDelimiter","handleCopy","useCallback","event","isModifierKeyPressed","ctrlKey","metaKey","String","fromCharCode","keyCode","target","textToCopy","selectedRows","current","getSelectedRows","size","getDataAsCsv","includeHeaders","delimiter","focusedCell","cellParams","getCellParams","id","field","delimiterCharacter","unstable_applyPipeProcessors","publishEvent","rootElementRef","onClipboardCopy"],"sources":["C:/Users/Adit/Desktop/mern-stack-final/frontend/node_modules/@mui/x-data-grid/hooks/features/clipboard/useGridClipboard.js"],"sourcesContent":["import * as React from 'react';\nimport { useGridApiOptionHandler, useGridNativeEventListener } from '../../utils';\nimport { gridFocusCellSelector } from '../focus/gridFocusStateSelector';\nimport { serializeCellValue } from '../export/serializers/csvSerializer';\nfunction writeToClipboardPolyfill(data) {\n  const span = document.createElement('span');\n  span.style.whiteSpace = 'pre';\n  span.style.userSelect = 'all';\n  span.style.opacity = '0px';\n  span.textContent = data;\n  document.body.appendChild(span);\n  const range = document.createRange();\n  range.selectNode(span);\n  const selection = window.getSelection();\n  selection.removeAllRanges();\n  selection.addRange(range);\n  try {\n    document.execCommand('copy');\n  } finally {\n    document.body.removeChild(span);\n  }\n}\nfunction copyToClipboard(data) {\n  if (navigator.clipboard) {\n    navigator.clipboard.writeText(data).catch(() => {\n      writeToClipboardPolyfill(data);\n    });\n  } else {\n    writeToClipboardPolyfill(data);\n  }\n}\nfunction hasNativeSelection(element) {\n  var _window$getSelection;\n  // When getSelection is called on an <iframe> that is not displayed Firefox will return null.\n  if ((_window$getSelection = window.getSelection()) != null && _window$getSelection.toString()) {\n    return true;\n  }\n\n  // window.getSelection() returns an empty string in Firefox for selections inside a form element.\n  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=85686.\n  // Instead, we can use element.selectionStart that is only defined on form elements.\n  if (element && (element.selectionEnd || 0) - (element.selectionStart || 0) > 0) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @requires useGridCsvExport (method)\n * @requires useGridSelection (method)\n */\nexport const useGridClipboard = (apiRef, props) => {\n  const ignoreValueFormatterProp = props.unstable_ignoreValueFormatterDuringExport;\n  const ignoreValueFormatter = (typeof ignoreValueFormatterProp === 'object' ? ignoreValueFormatterProp == null ? void 0 : ignoreValueFormatterProp.clipboardExport : ignoreValueFormatterProp) || false;\n  const clipboardCopyCellDelimiter = props.clipboardCopyCellDelimiter;\n  const handleCopy = React.useCallback(event => {\n    const isModifierKeyPressed = event.ctrlKey || event.metaKey;\n    // event.code === 'KeyC' is not enough as event.code assume a QWERTY keyboard layout which would\n    // be wrong with a Dvorak keyboard (as if pressing J).\n    if (String.fromCharCode(event.keyCode) !== 'C' || !isModifierKeyPressed) {\n      return;\n    }\n\n    // Do nothing if there's a native selection\n    if (hasNativeSelection(event.target)) {\n      return;\n    }\n    let textToCopy = '';\n    const selectedRows = apiRef.current.getSelectedRows();\n    if (selectedRows.size > 0) {\n      textToCopy = apiRef.current.getDataAsCsv({\n        includeHeaders: false,\n        // TODO: make it configurable\n        delimiter: clipboardCopyCellDelimiter\n      });\n    } else {\n      const focusedCell = gridFocusCellSelector(apiRef);\n      if (focusedCell) {\n        const cellParams = apiRef.current.getCellParams(focusedCell.id, focusedCell.field);\n        textToCopy = serializeCellValue(cellParams, {\n          delimiterCharacter: clipboardCopyCellDelimiter,\n          ignoreValueFormatter\n        });\n      }\n    }\n    textToCopy = apiRef.current.unstable_applyPipeProcessors('clipboardCopy', textToCopy);\n    if (textToCopy) {\n      copyToClipboard(textToCopy);\n      apiRef.current.publishEvent('clipboardCopy', textToCopy);\n    }\n  }, [apiRef, ignoreValueFormatter, clipboardCopyCellDelimiter]);\n  useGridNativeEventListener(apiRef, apiRef.current.rootElementRef, 'keydown', handleCopy);\n  useGridApiOptionHandler(apiRef, 'clipboardCopy', props.onClipboardCopy);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}