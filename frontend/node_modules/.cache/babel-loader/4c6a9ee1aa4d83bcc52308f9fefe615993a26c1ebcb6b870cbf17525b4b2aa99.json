{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Adit/Desktop/mern-stack-final/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nexport var GRID_ROOT_GROUP_ID = \"auto-generated-group-node-root\";\nexport var buildRootGroup = function buildRootGroup() {\n  return {\n    type: 'group',\n    id: GRID_ROOT_GROUP_ID,\n    depth: -1,\n    groupingField: null,\n    groupingKey: null,\n    isAutoGenerated: true,\n    children: [],\n    childrenFromPath: {},\n    childrenExpanded: true,\n    parent: null\n  };\n};\n\n/**\n * A helper function to check if the id provided is valid.\n * @param {GridRowId} id Id as [[GridRowId]].\n * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].\n * @param {string} detailErrorMessage A custom error message to display for invalid IDs\n */\nexport function checkGridRowIdIsValid(id, row) {\n  var detailErrorMessage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'A row was provided without id in the rows prop:';\n  if (id == null) {\n    throw new Error(['MUI: The data grid component requires all rows to have a unique `id` property.', 'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.', detailErrorMessage, JSON.stringify(row)].join('\\n'));\n  }\n}\nexport var getRowIdFromRowModel = function getRowIdFromRowModel(rowModel, getRowId, detailErrorMessage) {\n  var id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n};\nexport var createRowsInternalCache = function createRowsInternalCache(_ref) {\n  var rows = _ref.rows,\n    getRowId = _ref.getRowId,\n    loading = _ref.loading,\n    rowCount = _ref.rowCount;\n  var updates = {\n    type: 'full',\n    rows: []\n  };\n  var dataRowIdToModelLookup = {};\n  var dataRowIdToIdLookup = {};\n  for (var i = 0; i < rows.length; i += 1) {\n    var model = rows[i];\n    var id = getRowIdFromRowModel(model, getRowId);\n    dataRowIdToModelLookup[id] = model;\n    dataRowIdToIdLookup[id] = id;\n    updates.rows.push(id);\n  }\n  return {\n    rowsBeforePartialUpdates: rows,\n    loadingPropBeforePartialUpdates: loading,\n    rowCountPropBeforePartialUpdates: rowCount,\n    updates: updates,\n    dataRowIdToIdLookup: dataRowIdToIdLookup,\n    dataRowIdToModelLookup: dataRowIdToModelLookup\n  };\n};\nexport var getTopLevelRowCount = function getTopLevelRowCount(_ref2) {\n  var tree = _ref2.tree,\n    _ref2$rowCountProp = _ref2.rowCountProp,\n    rowCountProp = _ref2$rowCountProp === void 0 ? 0 : _ref2$rowCountProp;\n  var rootGroupNode = tree[GRID_ROOT_GROUP_ID];\n  return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));\n};\nexport var getRowsStateFromCache = function getRowsStateFromCache(_ref3) {\n  var apiRef = _ref3.apiRef,\n    _ref3$rowCountProp = _ref3.rowCountProp,\n    rowCountProp = _ref3$rowCountProp === void 0 ? 0 : _ref3$rowCountProp,\n    loadingProp = _ref3.loadingProp,\n    previousTree = _ref3.previousTree,\n    previousTreeDepths = _ref3.previousTreeDepths;\n  var cache = apiRef.current.caches.rows;\n\n  // 1. Apply the \"rowTreeCreation\" family processing.\n  var _apiRef$current$apply = apiRef.current.applyStrategyProcessor('rowTreeCreation', {\n      previousTree: previousTree,\n      previousTreeDepths: previousTreeDepths,\n      updates: cache.updates,\n      dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n      dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n    }),\n    unProcessedTree = _apiRef$current$apply.tree,\n    unProcessedTreeDepths = _apiRef$current$apply.treeDepths,\n    unProcessedDataRowIds = _apiRef$current$apply.dataRowIds,\n    groupingName = _apiRef$current$apply.groupingName;\n\n  // 2. Apply the \"hydrateRows\" pipe-processing.\n  var groupingParamsWithHydrateRows = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n    dataRowIds: unProcessedDataRowIds,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  });\n\n  // 3. Reset the cache updates\n  apiRef.current.caches.rows.updates = {\n    type: 'partial',\n    actions: {\n      insert: [],\n      modify: [],\n      remove: []\n    },\n    idToActionLookup: {}\n  };\n  return _extends({}, groupingParamsWithHydrateRows, {\n    totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length),\n    totalTopLevelRowCount: getTopLevelRowCount({\n      tree: groupingParamsWithHydrateRows.tree,\n      rowCountProp: rowCountProp\n    }),\n    groupingName: groupingName,\n    loading: loadingProp\n  });\n};\nexport var isAutoGeneratedRow = function isAutoGeneratedRow(rowNode) {\n  return rowNode.type === 'skeletonRow' || rowNode.type === 'footer' || rowNode.type === 'group' && rowNode.isAutoGenerated || rowNode.type === 'pinnedRow' && rowNode.isAutoGenerated;\n};\nexport var getTreeNodeDescendants = function getTreeNodeDescendants(tree, parentId, skipAutoGeneratedRows) {\n  var node = tree[parentId];\n  if (node.type !== 'group') {\n    return [];\n  }\n  var validDescendants = [];\n  for (var i = 0; i < node.children.length; i += 1) {\n    var child = node.children[i];\n    if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[child])) {\n      validDescendants.push(child);\n    }\n    validDescendants.push.apply(validDescendants, _toConsumableArray(getTreeNodeDescendants(tree, child, skipAutoGeneratedRows)));\n  }\n  if (!skipAutoGeneratedRows && node.footerId != null) {\n    validDescendants.push(node.footerId);\n  }\n  return validDescendants;\n};\nexport var updateCacheWithNewRows = function updateCacheWithNewRows(_ref4) {\n  var previousCache = _ref4.previousCache,\n    getRowId = _ref4.getRowId,\n    updates = _ref4.updates;\n  var _previousCache$update, _previousCache$update2, _previousCache$update3;\n  if (previousCache.updates.type === 'full') {\n    throw new Error('MUI: Unable to prepare a partial update if a full update is not applied yet');\n  }\n\n  // Remove duplicate updates.\n  // A server can batch updates, and send several updates for the same row in one fn call.\n  var uniqueUpdates = new Map();\n  updates.forEach(function (update) {\n    var id = getRowIdFromRowModel(update, getRowId, 'A row was provided without id when calling updateRows():');\n    if (uniqueUpdates.has(id)) {\n      uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n    } else {\n      uniqueUpdates.set(id, update);\n    }\n  });\n  var partialUpdates = {\n    type: 'partial',\n    actions: {\n      insert: _toConsumableArray((_previousCache$update = previousCache.updates.actions.insert) != null ? _previousCache$update : []),\n      modify: _toConsumableArray((_previousCache$update2 = previousCache.updates.actions.modify) != null ? _previousCache$update2 : []),\n      remove: _toConsumableArray((_previousCache$update3 = previousCache.updates.actions.remove) != null ? _previousCache$update3 : [])\n    },\n    idToActionLookup: _extends({}, previousCache.updates.idToActionLookup)\n  };\n  var dataRowIdToModelLookup = _extends({}, previousCache.dataRowIdToModelLookup);\n  var dataRowIdToIdLookup = _extends({}, previousCache.dataRowIdToIdLookup);\n  var alreadyAppliedActionsToRemove = {\n    insert: {},\n    modify: {},\n    remove: {}\n  };\n\n  // Depending on the action already applied to the data row,\n  // We might want drop the already-applied-update.\n  // For instance:\n  // - if you delete then insert, then you don't want to apply the deletion in the tree.\n  // - if you insert, then modify, then you just want to apply the insertion in the tree.\n  uniqueUpdates.forEach(function (partialRow, id) {\n    var actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id];\n\n    // Action === \"delete\"\n    // eslint-disable-next-line no-underscore-dangle\n    if (partialRow._action === 'delete') {\n      // If the data row has been removed since the last state update,\n      // Then do nothing.\n      if (actionAlreadyAppliedToRow === 'remove' || !dataRowIdToModelLookup[id]) {\n        return;\n      }\n\n      // If the data row has been inserted / modified since the last state update,\n      // Then drop this \"insert\" / \"modify\" update.\n      if (actionAlreadyAppliedToRow != null) {\n        alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id] = true;\n      }\n\n      // Remove the data row from the lookups and add it to the \"delete\" update.\n      partialUpdates.actions.remove.push(id);\n      delete dataRowIdToModelLookup[id];\n      delete dataRowIdToIdLookup[id];\n      return;\n    }\n    var oldRow = dataRowIdToModelLookup[id];\n\n    // Action === \"modify\"\n    if (oldRow) {\n      // If the data row has been removed since the last state update,\n      // Then drop this \"remove\" update and add it to the \"modify\" update instead.\n      if (actionAlreadyAppliedToRow === 'remove') {\n        alreadyAppliedActionsToRemove.remove[id] = true;\n        partialUpdates.actions.modify.push(id);\n      }\n      // If the date has not been inserted / modified since the last state update,\n      // Then add it to the \"modify\" update (if it has been inserted it should just remain \"inserted\").\n      else if (actionAlreadyAppliedToRow == null) {\n        partialUpdates.actions.modify.push(id);\n      }\n\n      // Update the data row lookups.\n      dataRowIdToModelLookup[id] = _extends({}, oldRow, partialRow);\n      return;\n    }\n\n    // Action === \"insert\"\n    // If the data row has been removed since the last state update,\n    // Then drop the \"remove\" update and add it to the \"insert\" update instead.\n    if (actionAlreadyAppliedToRow === 'remove') {\n      alreadyAppliedActionsToRemove.remove[id] = true;\n      partialUpdates.actions.insert.push(id);\n    }\n    // If the data row has not been inserted since the last state update,\n    // Then add it to the \"insert\" update.\n    // `actionAlreadyAppliedToRow` can't be equal to \"modify\", otherwise we would have an `oldRow` above.\n    else if (actionAlreadyAppliedToRow == null) {\n      partialUpdates.actions.insert.push(id);\n    }\n\n    // Update the data row lookups.\n    dataRowIdToModelLookup[id] = partialRow;\n    dataRowIdToIdLookup[id] = id;\n  });\n  var actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);\n  var _loop = function _loop() {\n    var actionType = actionTypeWithActionsToRemove[i];\n    var idsToRemove = alreadyAppliedActionsToRemove[actionType];\n    if (Object.keys(idsToRemove).length > 0) {\n      partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter(function (id) {\n        return !idsToRemove[id];\n      });\n    }\n  };\n  for (var i = 0; i < actionTypeWithActionsToRemove.length; i += 1) {\n    _loop();\n  }\n  return {\n    dataRowIdToModelLookup: dataRowIdToModelLookup,\n    dataRowIdToIdLookup: dataRowIdToIdLookup,\n    updates: partialUpdates,\n    rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,\n    loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,\n    rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates\n  };\n};\nexport function calculatePinnedRowsHeight(apiRef) {\n  var _pinnedRows$top, _pinnedRows$bottom;\n  var pinnedRows = gridPinnedRowsSelector(apiRef);\n  var topPinnedRowsHeight = (pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.reduce(function (acc, value) {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0)) || 0;\n  var bottomPinnedRowsHeight = (pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.reduce(function (acc, value) {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0)) || 0;\n  return {\n    top: topPinnedRowsHeight,\n    bottom: bottomPinnedRowsHeight\n  };\n}\nexport function getMinimalContentHeight(apiRef, rowHeight) {\n  var densityFactor = gridDensityFactorSelector(apiRef);\n  return 2 * Math.floor(rowHeight * densityFactor);\n}","map":{"version":3,"names":["_extends","gridPinnedRowsSelector","gridDensityFactorSelector","GRID_ROOT_GROUP_ID","buildRootGroup","type","id","depth","groupingField","groupingKey","isAutoGenerated","children","childrenFromPath","childrenExpanded","parent","checkGridRowIdIsValid","row","detailErrorMessage","arguments","length","undefined","Error","JSON","stringify","join","getRowIdFromRowModel","rowModel","getRowId","createRowsInternalCache","_ref","rows","loading","rowCount","updates","dataRowIdToModelLookup","dataRowIdToIdLookup","i","model","push","rowsBeforePartialUpdates","loadingPropBeforePartialUpdates","rowCountPropBeforePartialUpdates","getTopLevelRowCount","_ref2","tree","_ref2$rowCountProp","rowCountProp","rootGroupNode","Math","max","footerId","getRowsStateFromCache","_ref3","apiRef","_ref3$rowCountProp","loadingProp","previousTree","previousTreeDepths","cache","current","caches","_apiRef$current$apply","applyStrategyProcessor","unProcessedTree","unProcessedTreeDepths","treeDepths","unProcessedDataRowIds","dataRowIds","groupingName","groupingParamsWithHydrateRows","unstable_applyPipeProcessors","actions","insert","modify","remove","idToActionLookup","totalRowCount","totalTopLevelRowCount","isAutoGeneratedRow","rowNode","getTreeNodeDescendants","parentId","skipAutoGeneratedRows","node","validDescendants","child","apply","_toConsumableArray","updateCacheWithNewRows","_ref4","previousCache","_previousCache$update","_previousCache$update2","_previousCache$update3","uniqueUpdates","Map","forEach","update","has","set","get","partialUpdates","alreadyAppliedActionsToRemove","partialRow","actionAlreadyAppliedToRow","_action","oldRow","actionTypeWithActionsToRemove","Object","keys","_loop","actionType","idsToRemove","filter","calculatePinnedRowsHeight","_pinnedRows$top","_pinnedRows$bottom","pinnedRows","topPinnedRowsHeight","top","reduce","acc","value","unstable_getRowHeight","bottomPinnedRowsHeight","bottom","getMinimalContentHeight","rowHeight","densityFactor","floor"],"sources":["C:/Users/Adit/Desktop/mern-stack-final/frontend/node_modules/@mui/x-data-grid/hooks/features/rows/gridRowsUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nexport const GRID_ROOT_GROUP_ID = `auto-generated-group-node-root`;\nexport const buildRootGroup = () => ({\n  type: 'group',\n  id: GRID_ROOT_GROUP_ID,\n  depth: -1,\n  groupingField: null,\n  groupingKey: null,\n  isAutoGenerated: true,\n  children: [],\n  childrenFromPath: {},\n  childrenExpanded: true,\n  parent: null\n});\n\n/**\n * A helper function to check if the id provided is valid.\n * @param {GridRowId} id Id as [[GridRowId]].\n * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].\n * @param {string} detailErrorMessage A custom error message to display for invalid IDs\n */\nexport function checkGridRowIdIsValid(id, row, detailErrorMessage = 'A row was provided without id in the rows prop:') {\n  if (id == null) {\n    throw new Error(['MUI: The data grid component requires all rows to have a unique `id` property.', 'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.', detailErrorMessage, JSON.stringify(row)].join('\\n'));\n  }\n}\nexport const getRowIdFromRowModel = (rowModel, getRowId, detailErrorMessage) => {\n  const id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n};\nexport const createRowsInternalCache = ({\n  rows,\n  getRowId,\n  loading,\n  rowCount\n}) => {\n  const updates = {\n    type: 'full',\n    rows: []\n  };\n  const dataRowIdToModelLookup = {};\n  const dataRowIdToIdLookup = {};\n  for (let i = 0; i < rows.length; i += 1) {\n    const model = rows[i];\n    const id = getRowIdFromRowModel(model, getRowId);\n    dataRowIdToModelLookup[id] = model;\n    dataRowIdToIdLookup[id] = id;\n    updates.rows.push(id);\n  }\n  return {\n    rowsBeforePartialUpdates: rows,\n    loadingPropBeforePartialUpdates: loading,\n    rowCountPropBeforePartialUpdates: rowCount,\n    updates,\n    dataRowIdToIdLookup,\n    dataRowIdToModelLookup\n  };\n};\nexport const getTopLevelRowCount = ({\n  tree,\n  rowCountProp = 0\n}) => {\n  const rootGroupNode = tree[GRID_ROOT_GROUP_ID];\n  return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));\n};\nexport const getRowsStateFromCache = ({\n  apiRef,\n  rowCountProp = 0,\n  loadingProp,\n  previousTree,\n  previousTreeDepths\n}) => {\n  const cache = apiRef.current.caches.rows;\n\n  // 1. Apply the \"rowTreeCreation\" family processing.\n  const {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIds: unProcessedDataRowIds,\n    groupingName\n  } = apiRef.current.applyStrategyProcessor('rowTreeCreation', {\n    previousTree,\n    previousTreeDepths,\n    updates: cache.updates,\n    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  });\n\n  // 2. Apply the \"hydrateRows\" pipe-processing.\n  const groupingParamsWithHydrateRows = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n    dataRowIds: unProcessedDataRowIds,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  });\n\n  // 3. Reset the cache updates\n  apiRef.current.caches.rows.updates = {\n    type: 'partial',\n    actions: {\n      insert: [],\n      modify: [],\n      remove: []\n    },\n    idToActionLookup: {}\n  };\n  return _extends({}, groupingParamsWithHydrateRows, {\n    totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length),\n    totalTopLevelRowCount: getTopLevelRowCount({\n      tree: groupingParamsWithHydrateRows.tree,\n      rowCountProp\n    }),\n    groupingName,\n    loading: loadingProp\n  });\n};\nexport const isAutoGeneratedRow = rowNode => rowNode.type === 'skeletonRow' || rowNode.type === 'footer' || rowNode.type === 'group' && rowNode.isAutoGenerated || rowNode.type === 'pinnedRow' && rowNode.isAutoGenerated;\nexport const getTreeNodeDescendants = (tree, parentId, skipAutoGeneratedRows) => {\n  const node = tree[parentId];\n  if (node.type !== 'group') {\n    return [];\n  }\n  const validDescendants = [];\n  for (let i = 0; i < node.children.length; i += 1) {\n    const child = node.children[i];\n    if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[child])) {\n      validDescendants.push(child);\n    }\n    validDescendants.push(...getTreeNodeDescendants(tree, child, skipAutoGeneratedRows));\n  }\n  if (!skipAutoGeneratedRows && node.footerId != null) {\n    validDescendants.push(node.footerId);\n  }\n  return validDescendants;\n};\nexport const updateCacheWithNewRows = ({\n  previousCache,\n  getRowId,\n  updates\n}) => {\n  var _previousCache$update, _previousCache$update2, _previousCache$update3;\n  if (previousCache.updates.type === 'full') {\n    throw new Error('MUI: Unable to prepare a partial update if a full update is not applied yet');\n  }\n\n  // Remove duplicate updates.\n  // A server can batch updates, and send several updates for the same row in one fn call.\n  const uniqueUpdates = new Map();\n  updates.forEach(update => {\n    const id = getRowIdFromRowModel(update, getRowId, 'A row was provided without id when calling updateRows():');\n    if (uniqueUpdates.has(id)) {\n      uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n    } else {\n      uniqueUpdates.set(id, update);\n    }\n  });\n  const partialUpdates = {\n    type: 'partial',\n    actions: {\n      insert: [...((_previousCache$update = previousCache.updates.actions.insert) != null ? _previousCache$update : [])],\n      modify: [...((_previousCache$update2 = previousCache.updates.actions.modify) != null ? _previousCache$update2 : [])],\n      remove: [...((_previousCache$update3 = previousCache.updates.actions.remove) != null ? _previousCache$update3 : [])]\n    },\n    idToActionLookup: _extends({}, previousCache.updates.idToActionLookup)\n  };\n  const dataRowIdToModelLookup = _extends({}, previousCache.dataRowIdToModelLookup);\n  const dataRowIdToIdLookup = _extends({}, previousCache.dataRowIdToIdLookup);\n  const alreadyAppliedActionsToRemove = {\n    insert: {},\n    modify: {},\n    remove: {}\n  };\n\n  // Depending on the action already applied to the data row,\n  // We might want drop the already-applied-update.\n  // For instance:\n  // - if you delete then insert, then you don't want to apply the deletion in the tree.\n  // - if you insert, then modify, then you just want to apply the insertion in the tree.\n  uniqueUpdates.forEach((partialRow, id) => {\n    const actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id];\n\n    // Action === \"delete\"\n    // eslint-disable-next-line no-underscore-dangle\n    if (partialRow._action === 'delete') {\n      // If the data row has been removed since the last state update,\n      // Then do nothing.\n      if (actionAlreadyAppliedToRow === 'remove' || !dataRowIdToModelLookup[id]) {\n        return;\n      }\n\n      // If the data row has been inserted / modified since the last state update,\n      // Then drop this \"insert\" / \"modify\" update.\n      if (actionAlreadyAppliedToRow != null) {\n        alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id] = true;\n      }\n\n      // Remove the data row from the lookups and add it to the \"delete\" update.\n      partialUpdates.actions.remove.push(id);\n      delete dataRowIdToModelLookup[id];\n      delete dataRowIdToIdLookup[id];\n      return;\n    }\n    const oldRow = dataRowIdToModelLookup[id];\n\n    // Action === \"modify\"\n    if (oldRow) {\n      // If the data row has been removed since the last state update,\n      // Then drop this \"remove\" update and add it to the \"modify\" update instead.\n      if (actionAlreadyAppliedToRow === 'remove') {\n        alreadyAppliedActionsToRemove.remove[id] = true;\n        partialUpdates.actions.modify.push(id);\n      }\n      // If the date has not been inserted / modified since the last state update,\n      // Then add it to the \"modify\" update (if it has been inserted it should just remain \"inserted\").\n      else if (actionAlreadyAppliedToRow == null) {\n        partialUpdates.actions.modify.push(id);\n      }\n\n      // Update the data row lookups.\n      dataRowIdToModelLookup[id] = _extends({}, oldRow, partialRow);\n      return;\n    }\n\n    // Action === \"insert\"\n    // If the data row has been removed since the last state update,\n    // Then drop the \"remove\" update and add it to the \"insert\" update instead.\n    if (actionAlreadyAppliedToRow === 'remove') {\n      alreadyAppliedActionsToRemove.remove[id] = true;\n      partialUpdates.actions.insert.push(id);\n    }\n    // If the data row has not been inserted since the last state update,\n    // Then add it to the \"insert\" update.\n    // `actionAlreadyAppliedToRow` can't be equal to \"modify\", otherwise we would have an `oldRow` above.\n    else if (actionAlreadyAppliedToRow == null) {\n      partialUpdates.actions.insert.push(id);\n    }\n\n    // Update the data row lookups.\n    dataRowIdToModelLookup[id] = partialRow;\n    dataRowIdToIdLookup[id] = id;\n  });\n  const actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);\n  for (let i = 0; i < actionTypeWithActionsToRemove.length; i += 1) {\n    const actionType = actionTypeWithActionsToRemove[i];\n    const idsToRemove = alreadyAppliedActionsToRemove[actionType];\n    if (Object.keys(idsToRemove).length > 0) {\n      partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter(id => !idsToRemove[id]);\n    }\n  }\n  return {\n    dataRowIdToModelLookup,\n    dataRowIdToIdLookup,\n    updates: partialUpdates,\n    rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,\n    loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,\n    rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates\n  };\n};\nexport function calculatePinnedRowsHeight(apiRef) {\n  var _pinnedRows$top, _pinnedRows$bottom;\n  const pinnedRows = gridPinnedRowsSelector(apiRef);\n  const topPinnedRowsHeight = (pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.reduce((acc, value) => {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0)) || 0;\n  const bottomPinnedRowsHeight = (pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.reduce((acc, value) => {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0)) || 0;\n  return {\n    top: topPinnedRowsHeight,\n    bottom: bottomPinnedRowsHeight\n  };\n}\nexport function getMinimalContentHeight(apiRef, rowHeight) {\n  const densityFactor = gridDensityFactorSelector(apiRef);\n  return 2 * Math.floor(rowHeight * densityFactor);\n}"],"mappings":";AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,SAASC,sBAAsB,QAAQ,oBAAoB;AAC3D,SAASC,yBAAyB,QAAQ,4BAA4B;AACtE,OAAO,IAAMC,kBAAkB,mCAAmC;AAClE,OAAO,IAAMC,cAAc,GAAG,SAAjBA,cAAcA,CAAA;EAAA,OAAU;IACnCC,IAAI,EAAE,OAAO;IACbC,EAAE,EAAEH,kBAAkB;IACtBI,KAAK,EAAE,CAAC,CAAC;IACTC,aAAa,EAAE,IAAI;IACnBC,WAAW,EAAE,IAAI;IACjBC,eAAe,EAAE,IAAI;IACrBC,QAAQ,EAAE,EAAE;IACZC,gBAAgB,EAAE,CAAC,CAAC;IACpBC,gBAAgB,EAAE,IAAI;IACtBC,MAAM,EAAE;EACV,CAAC;AAAA,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,qBAAqBA,CAACT,EAAE,EAAEU,GAAG,EAA0E;EAAA,IAAxEC,kBAAkB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,iDAAiD;EACnH,IAAIZ,EAAE,IAAI,IAAI,EAAE;IACd,MAAM,IAAIe,KAAK,CAAC,CAAC,gFAAgF,EAAE,qFAAqF,EAAEJ,kBAAkB,EAAEK,IAAI,CAACC,SAAS,CAACP,GAAG,CAAC,CAAC,CAACQ,IAAI,CAAC,IAAI,CAAC,CAAC;EAChP;AACF;AACA,OAAO,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAIC,QAAQ,EAAEC,QAAQ,EAAEV,kBAAkB,EAAK;EAC9E,IAAMX,EAAE,GAAGqB,QAAQ,GAAGA,QAAQ,CAACD,QAAQ,CAAC,GAAGA,QAAQ,CAACpB,EAAE;EACtDS,qBAAqB,CAACT,EAAE,EAAEoB,QAAQ,EAAET,kBAAkB,CAAC;EACvD,OAAOX,EAAE;AACX,CAAC;AACD,OAAO,IAAMsB,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAAAC,IAAA,EAK9B;EAAA,IAJJC,IAAI,GAAAD,IAAA,CAAJC,IAAI;IACJH,QAAQ,GAAAE,IAAA,CAARF,QAAQ;IACRI,OAAO,GAAAF,IAAA,CAAPE,OAAO;IACPC,QAAQ,GAAAH,IAAA,CAARG,QAAQ;EAER,IAAMC,OAAO,GAAG;IACd5B,IAAI,EAAE,MAAM;IACZyB,IAAI,EAAE;EACR,CAAC;EACD,IAAMI,sBAAsB,GAAG,CAAC,CAAC;EACjC,IAAMC,mBAAmB,GAAG,CAAC,CAAC;EAC9B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,IAAI,CAACX,MAAM,EAAEiB,CAAC,IAAI,CAAC,EAAE;IACvC,IAAMC,KAAK,GAAGP,IAAI,CAACM,CAAC,CAAC;IACrB,IAAM9B,EAAE,GAAGmB,oBAAoB,CAACY,KAAK,EAAEV,QAAQ,CAAC;IAChDO,sBAAsB,CAAC5B,EAAE,CAAC,GAAG+B,KAAK;IAClCF,mBAAmB,CAAC7B,EAAE,CAAC,GAAGA,EAAE;IAC5B2B,OAAO,CAACH,IAAI,CAACQ,IAAI,CAAChC,EAAE,CAAC;EACvB;EACA,OAAO;IACLiC,wBAAwB,EAAET,IAAI;IAC9BU,+BAA+B,EAAET,OAAO;IACxCU,gCAAgC,EAAET,QAAQ;IAC1CC,OAAO,EAAPA,OAAO;IACPE,mBAAmB,EAAnBA,mBAAmB;IACnBD,sBAAsB,EAAtBA;EACF,CAAC;AACH,CAAC;AACD,OAAO,IAAMQ,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAAC,KAAA,EAG1B;EAAA,IAFJC,IAAI,GAAAD,KAAA,CAAJC,IAAI;IAAAC,kBAAA,GAAAF,KAAA,CACJG,YAAY;IAAZA,YAAY,GAAAD,kBAAA,cAAG,CAAC,GAAAA,kBAAA;EAEhB,IAAME,aAAa,GAAGH,IAAI,CAACzC,kBAAkB,CAAC;EAC9C,OAAO6C,IAAI,CAACC,GAAG,CAACH,YAAY,EAAEC,aAAa,CAACpC,QAAQ,CAACQ,MAAM,IAAI4B,aAAa,CAACG,QAAQ,IAAI,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AACzG,CAAC;AACD,OAAO,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAqBA,CAAAC,KAAA,EAM5B;EAAA,IALJC,MAAM,GAAAD,KAAA,CAANC,MAAM;IAAAC,kBAAA,GAAAF,KAAA,CACNN,YAAY;IAAZA,YAAY,GAAAQ,kBAAA,cAAG,CAAC,GAAAA,kBAAA;IAChBC,WAAW,GAAAH,KAAA,CAAXG,WAAW;IACXC,YAAY,GAAAJ,KAAA,CAAZI,YAAY;IACZC,kBAAkB,GAAAL,KAAA,CAAlBK,kBAAkB;EAElB,IAAMC,KAAK,GAAGL,MAAM,CAACM,OAAO,CAACC,MAAM,CAAC9B,IAAI;;EAExC;EACA,IAAA+B,qBAAA,GAKIR,MAAM,CAACM,OAAO,CAACG,sBAAsB,CAAC,iBAAiB,EAAE;MAC3DN,YAAY,EAAZA,YAAY;MACZC,kBAAkB,EAAlBA,kBAAkB;MAClBxB,OAAO,EAAEyB,KAAK,CAACzB,OAAO;MACtBE,mBAAmB,EAAEuB,KAAK,CAACvB,mBAAmB;MAC9CD,sBAAsB,EAAEwB,KAAK,CAACxB;IAChC,CAAC,CAAC;IAVM6B,eAAe,GAAAF,qBAAA,CAArBjB,IAAI;IACQoB,qBAAqB,GAAAH,qBAAA,CAAjCI,UAAU;IACEC,qBAAqB,GAAAL,qBAAA,CAAjCM,UAAU;IACVC,YAAY,GAAAP,qBAAA,CAAZO,YAAY;;EASd;EACA,IAAMC,6BAA6B,GAAGhB,MAAM,CAACM,OAAO,CAACW,4BAA4B,CAAC,aAAa,EAAE;IAC/F1B,IAAI,EAAEmB,eAAe;IACrBE,UAAU,EAAED,qBAAqB;IACjC7B,mBAAmB,EAAEuB,KAAK,CAACvB,mBAAmB;IAC9CgC,UAAU,EAAED,qBAAqB;IACjChC,sBAAsB,EAAEwB,KAAK,CAACxB;EAChC,CAAC,CAAC;;EAEF;EACAmB,MAAM,CAACM,OAAO,CAACC,MAAM,CAAC9B,IAAI,CAACG,OAAO,GAAG;IACnC5B,IAAI,EAAE,SAAS;IACfkE,OAAO,EAAE;MACPC,MAAM,EAAE,EAAE;MACVC,MAAM,EAAE,EAAE;MACVC,MAAM,EAAE;IACV,CAAC;IACDC,gBAAgB,EAAE,CAAC;EACrB,CAAC;EACD,OAAO3E,QAAQ,CAAC,CAAC,CAAC,EAAEqE,6BAA6B,EAAE;IACjDO,aAAa,EAAE5B,IAAI,CAACC,GAAG,CAACH,YAAY,EAAEuB,6BAA6B,CAACF,UAAU,CAAChD,MAAM,CAAC;IACtF0D,qBAAqB,EAAEnC,mBAAmB,CAAC;MACzCE,IAAI,EAAEyB,6BAA6B,CAACzB,IAAI;MACxCE,YAAY,EAAZA;IACF,CAAC,CAAC;IACFsB,YAAY,EAAZA,YAAY;IACZrC,OAAO,EAAEwB;EACX,CAAC,CAAC;AACJ,CAAC;AACD,OAAO,IAAMuB,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAGC,OAAO;EAAA,OAAIA,OAAO,CAAC1E,IAAI,KAAK,aAAa,IAAI0E,OAAO,CAAC1E,IAAI,KAAK,QAAQ,IAAI0E,OAAO,CAAC1E,IAAI,KAAK,OAAO,IAAI0E,OAAO,CAACrE,eAAe,IAAIqE,OAAO,CAAC1E,IAAI,KAAK,WAAW,IAAI0E,OAAO,CAACrE,eAAe;AAAA;AAC1N,OAAO,IAAMsE,sBAAsB,GAAG,SAAzBA,sBAAsBA,CAAIpC,IAAI,EAAEqC,QAAQ,EAAEC,qBAAqB,EAAK;EAC/E,IAAMC,IAAI,GAAGvC,IAAI,CAACqC,QAAQ,CAAC;EAC3B,IAAIE,IAAI,CAAC9E,IAAI,KAAK,OAAO,EAAE;IACzB,OAAO,EAAE;EACX;EACA,IAAM+E,gBAAgB,GAAG,EAAE;EAC3B,KAAK,IAAIhD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+C,IAAI,CAACxE,QAAQ,CAACQ,MAAM,EAAEiB,CAAC,IAAI,CAAC,EAAE;IAChD,IAAMiD,KAAK,GAAGF,IAAI,CAACxE,QAAQ,CAACyB,CAAC,CAAC;IAC9B,IAAI,CAAC8C,qBAAqB,IAAI,CAACJ,kBAAkB,CAAClC,IAAI,CAACyC,KAAK,CAAC,CAAC,EAAE;MAC9DD,gBAAgB,CAAC9C,IAAI,CAAC+C,KAAK,CAAC;IAC9B;IACAD,gBAAgB,CAAC9C,IAAI,CAAAgD,KAAA,CAArBF,gBAAgB,EAAAG,kBAAA,CAASP,sBAAsB,CAACpC,IAAI,EAAEyC,KAAK,EAAEH,qBAAqB,CAAC,EAAC;EACtF;EACA,IAAI,CAACA,qBAAqB,IAAIC,IAAI,CAACjC,QAAQ,IAAI,IAAI,EAAE;IACnDkC,gBAAgB,CAAC9C,IAAI,CAAC6C,IAAI,CAACjC,QAAQ,CAAC;EACtC;EACA,OAAOkC,gBAAgB;AACzB,CAAC;AACD,OAAO,IAAMI,sBAAsB,GAAG,SAAzBA,sBAAsBA,CAAAC,KAAA,EAI7B;EAAA,IAHJC,aAAa,GAAAD,KAAA,CAAbC,aAAa;IACb/D,QAAQ,GAAA8D,KAAA,CAAR9D,QAAQ;IACRM,OAAO,GAAAwD,KAAA,CAAPxD,OAAO;EAEP,IAAI0D,qBAAqB,EAAEC,sBAAsB,EAAEC,sBAAsB;EACzE,IAAIH,aAAa,CAACzD,OAAO,CAAC5B,IAAI,KAAK,MAAM,EAAE;IACzC,MAAM,IAAIgB,KAAK,CAAC,6EAA6E,CAAC;EAChG;;EAEA;EACA;EACA,IAAMyE,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC/B9D,OAAO,CAAC+D,OAAO,CAAC,UAAAC,MAAM,EAAI;IACxB,IAAM3F,EAAE,GAAGmB,oBAAoB,CAACwE,MAAM,EAAEtE,QAAQ,EAAE,0DAA0D,CAAC;IAC7G,IAAImE,aAAa,CAACI,GAAG,CAAC5F,EAAE,CAAC,EAAE;MACzBwF,aAAa,CAACK,GAAG,CAAC7F,EAAE,EAAEN,QAAQ,CAAC,CAAC,CAAC,EAAE8F,aAAa,CAACM,GAAG,CAAC9F,EAAE,CAAC,EAAE2F,MAAM,CAAC,CAAC;IACpE,CAAC,MAAM;MACLH,aAAa,CAACK,GAAG,CAAC7F,EAAE,EAAE2F,MAAM,CAAC;IAC/B;EACF,CAAC,CAAC;EACF,IAAMI,cAAc,GAAG;IACrBhG,IAAI,EAAE,SAAS;IACfkE,OAAO,EAAE;MACPC,MAAM,EAAAe,kBAAA,CAAO,CAACI,qBAAqB,GAAGD,aAAa,CAACzD,OAAO,CAACsC,OAAO,CAACC,MAAM,KAAK,IAAI,GAAGmB,qBAAqB,GAAG,EAAE,CAAE;MAClHlB,MAAM,EAAAc,kBAAA,CAAO,CAACK,sBAAsB,GAAGF,aAAa,CAACzD,OAAO,CAACsC,OAAO,CAACE,MAAM,KAAK,IAAI,GAAGmB,sBAAsB,GAAG,EAAE,CAAE;MACpHlB,MAAM,EAAAa,kBAAA,CAAO,CAACM,sBAAsB,GAAGH,aAAa,CAACzD,OAAO,CAACsC,OAAO,CAACG,MAAM,KAAK,IAAI,GAAGmB,sBAAsB,GAAG,EAAE;IACpH,CAAC;IACDlB,gBAAgB,EAAE3E,QAAQ,CAAC,CAAC,CAAC,EAAE0F,aAAa,CAACzD,OAAO,CAAC0C,gBAAgB;EACvE,CAAC;EACD,IAAMzC,sBAAsB,GAAGlC,QAAQ,CAAC,CAAC,CAAC,EAAE0F,aAAa,CAACxD,sBAAsB,CAAC;EACjF,IAAMC,mBAAmB,GAAGnC,QAAQ,CAAC,CAAC,CAAC,EAAE0F,aAAa,CAACvD,mBAAmB,CAAC;EAC3E,IAAMmE,6BAA6B,GAAG;IACpC9B,MAAM,EAAE,CAAC,CAAC;IACVC,MAAM,EAAE,CAAC,CAAC;IACVC,MAAM,EAAE,CAAC;EACX,CAAC;;EAED;EACA;EACA;EACA;EACA;EACAoB,aAAa,CAACE,OAAO,CAAC,UAACO,UAAU,EAAEjG,EAAE,EAAK;IACxC,IAAMkG,yBAAyB,GAAGH,cAAc,CAAC1B,gBAAgB,CAACrE,EAAE,CAAC;;IAErE;IACA;IACA,IAAIiG,UAAU,CAACE,OAAO,KAAK,QAAQ,EAAE;MACnC;MACA;MACA,IAAID,yBAAyB,KAAK,QAAQ,IAAI,CAACtE,sBAAsB,CAAC5B,EAAE,CAAC,EAAE;QACzE;MACF;;MAEA;MACA;MACA,IAAIkG,yBAAyB,IAAI,IAAI,EAAE;QACrCF,6BAA6B,CAACE,yBAAyB,CAAC,CAAClG,EAAE,CAAC,GAAG,IAAI;MACrE;;MAEA;MACA+F,cAAc,CAAC9B,OAAO,CAACG,MAAM,CAACpC,IAAI,CAAChC,EAAE,CAAC;MACtC,OAAO4B,sBAAsB,CAAC5B,EAAE,CAAC;MACjC,OAAO6B,mBAAmB,CAAC7B,EAAE,CAAC;MAC9B;IACF;IACA,IAAMoG,MAAM,GAAGxE,sBAAsB,CAAC5B,EAAE,CAAC;;IAEzC;IACA,IAAIoG,MAAM,EAAE;MACV;MACA;MACA,IAAIF,yBAAyB,KAAK,QAAQ,EAAE;QAC1CF,6BAA6B,CAAC5B,MAAM,CAACpE,EAAE,CAAC,GAAG,IAAI;QAC/C+F,cAAc,CAAC9B,OAAO,CAACE,MAAM,CAACnC,IAAI,CAAChC,EAAE,CAAC;MACxC;MACA;MACA;MAAA,KACK,IAAIkG,yBAAyB,IAAI,IAAI,EAAE;QAC1CH,cAAc,CAAC9B,OAAO,CAACE,MAAM,CAACnC,IAAI,CAAChC,EAAE,CAAC;MACxC;;MAEA;MACA4B,sBAAsB,CAAC5B,EAAE,CAAC,GAAGN,QAAQ,CAAC,CAAC,CAAC,EAAE0G,MAAM,EAAEH,UAAU,CAAC;MAC7D;IACF;;IAEA;IACA;IACA;IACA,IAAIC,yBAAyB,KAAK,QAAQ,EAAE;MAC1CF,6BAA6B,CAAC5B,MAAM,CAACpE,EAAE,CAAC,GAAG,IAAI;MAC/C+F,cAAc,CAAC9B,OAAO,CAACC,MAAM,CAAClC,IAAI,CAAChC,EAAE,CAAC;IACxC;IACA;IACA;IACA;IAAA,KACK,IAAIkG,yBAAyB,IAAI,IAAI,EAAE;MAC1CH,cAAc,CAAC9B,OAAO,CAACC,MAAM,CAAClC,IAAI,CAAChC,EAAE,CAAC;IACxC;;IAEA;IACA4B,sBAAsB,CAAC5B,EAAE,CAAC,GAAGiG,UAAU;IACvCpE,mBAAmB,CAAC7B,EAAE,CAAC,GAAGA,EAAE;EAC9B,CAAC,CAAC;EACF,IAAMqG,6BAA6B,GAAGC,MAAM,CAACC,IAAI,CAACP,6BAA6B,CAAC;EAAC,IAAAQ,KAAA,YAAAA,MAAA,EACf;IAChE,IAAMC,UAAU,GAAGJ,6BAA6B,CAACvE,CAAC,CAAC;IACnD,IAAM4E,WAAW,GAAGV,6BAA6B,CAACS,UAAU,CAAC;IAC7D,IAAIH,MAAM,CAACC,IAAI,CAACG,WAAW,CAAC,CAAC7F,MAAM,GAAG,CAAC,EAAE;MACvCkF,cAAc,CAAC9B,OAAO,CAACwC,UAAU,CAAC,GAAGV,cAAc,CAAC9B,OAAO,CAACwC,UAAU,CAAC,CAACE,MAAM,CAAC,UAAA3G,EAAE;QAAA,OAAI,CAAC0G,WAAW,CAAC1G,EAAE,CAAC;MAAA,EAAC;IACxG;EACF,CAAC;EAND,KAAK,IAAI8B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuE,6BAA6B,CAACxF,MAAM,EAAEiB,CAAC,IAAI,CAAC;IAAA0E,KAAA;EAAA;EAOhE,OAAO;IACL5E,sBAAsB,EAAtBA,sBAAsB;IACtBC,mBAAmB,EAAnBA,mBAAmB;IACnBF,OAAO,EAAEoE,cAAc;IACvB9D,wBAAwB,EAAEmD,aAAa,CAACnD,wBAAwB;IAChEC,+BAA+B,EAAEkD,aAAa,CAAClD,+BAA+B;IAC9EC,gCAAgC,EAAEiD,aAAa,CAACjD;EAClD,CAAC;AACH,CAAC;AACD,OAAO,SAASyE,yBAAyBA,CAAC7D,MAAM,EAAE;EAChD,IAAI8D,eAAe,EAAEC,kBAAkB;EACvC,IAAMC,UAAU,GAAGpH,sBAAsB,CAACoD,MAAM,CAAC;EACjD,IAAMiE,mBAAmB,GAAG,CAACD,UAAU,IAAI,IAAI,GAAG,KAAK,CAAC,GAAG,CAACF,eAAe,GAAGE,UAAU,CAACE,GAAG,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGJ,eAAe,CAACK,MAAM,CAAC,UAACC,GAAG,EAAEC,KAAK,EAAK;IACtJD,GAAG,IAAIpE,MAAM,CAACM,OAAO,CAACgE,qBAAqB,CAACD,KAAK,CAACpH,EAAE,CAAC;IACrD,OAAOmH,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC;EACX,IAAMG,sBAAsB,GAAG,CAACP,UAAU,IAAI,IAAI,GAAG,KAAK,CAAC,GAAG,CAACD,kBAAkB,GAAGC,UAAU,CAACQ,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGT,kBAAkB,CAACI,MAAM,CAAC,UAACC,GAAG,EAAEC,KAAK,EAAK;IAClKD,GAAG,IAAIpE,MAAM,CAACM,OAAO,CAACgE,qBAAqB,CAACD,KAAK,CAACpH,EAAE,CAAC;IACrD,OAAOmH,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC;EACX,OAAO;IACLF,GAAG,EAAED,mBAAmB;IACxBO,MAAM,EAAED;EACV,CAAC;AACH;AACA,OAAO,SAASE,uBAAuBA,CAACzE,MAAM,EAAE0E,SAAS,EAAE;EACzD,IAAMC,aAAa,GAAG9H,yBAAyB,CAACmD,MAAM,CAAC;EACvD,OAAO,CAAC,GAAGL,IAAI,CAACiF,KAAK,CAACF,SAAS,GAAGC,aAAa,CAAC;AAClD"},"metadata":{},"sourceType":"module","externalDependencies":[]}