{"ast":null,"code":"import * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\n/**\n * @requires useGridColumns (method, event)\n * @requires useGridParamsApi (method)\n */\nexport var useGridColumnSpanning = function useGridColumnSpanning(apiRef) {\n  var lookup = React.useRef({});\n  var setCellColSpanInfo = React.useCallback(function (rowId, columnIndex, cellColSpanInfo) {\n    var sizes = lookup.current;\n    if (!sizes[rowId]) {\n      sizes[rowId] = {};\n    }\n    sizes[rowId][columnIndex] = cellColSpanInfo;\n  }, []);\n  var getCellColSpanInfo = React.useCallback(function (rowId, columnIndex) {\n    var _lookup$current$rowId;\n    return (_lookup$current$rowId = lookup.current[rowId]) == null ? void 0 : _lookup$current$rowId[columnIndex];\n  }, []);\n\n  // Calculate `colSpan` for the cell.\n  var calculateCellColSpan = React.useCallback(function (params) {\n    var columnIndex = params.columnIndex,\n      rowId = params.rowId,\n      minFirstColumnIndex = params.minFirstColumnIndex,\n      maxLastColumnIndex = params.maxLastColumnIndex,\n      columns = params.columns;\n    var columnsLength = columns.length;\n    var column = columns[columnIndex];\n    var colSpan = typeof column.colSpan === 'function' ? column.colSpan(apiRef.current.getCellParams(rowId, column.field)) : column.colSpan;\n    if (!colSpan || colSpan === 1) {\n      setCellColSpanInfo(rowId, columnIndex, {\n        spannedByColSpan: false,\n        cellProps: {\n          colSpan: 1,\n          width: column.computedWidth\n        }\n      });\n      return {\n        colSpan: 1\n      };\n    }\n    var width = column.computedWidth;\n    for (var j = 1; j < colSpan; j += 1) {\n      var nextColumnIndex = columnIndex + j;\n      // Cells should be spanned only within their column section (left-pinned, right-pinned and unpinned).\n      if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {\n        var nextColumn = columns[nextColumnIndex];\n        width += nextColumn.computedWidth;\n        setCellColSpanInfo(rowId, columnIndex + j, {\n          spannedByColSpan: true,\n          rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),\n          leftVisibleCellIndex: columnIndex\n        });\n      }\n      setCellColSpanInfo(rowId, columnIndex, {\n        spannedByColSpan: false,\n        cellProps: {\n          colSpan: colSpan,\n          width: width\n        }\n      });\n    }\n    return {\n      colSpan: colSpan\n    };\n  }, [apiRef, setCellColSpanInfo]);\n\n  // Calculate `colSpan` for each cell in the row\n  var calculateColSpan = React.useCallback(function (_ref) {\n    var rowId = _ref.rowId,\n      minFirstColumn = _ref.minFirstColumn,\n      maxLastColumn = _ref.maxLastColumn,\n      columns = _ref.columns;\n    for (var i = minFirstColumn; i < maxLastColumn; i += 1) {\n      var cellProps = calculateCellColSpan({\n        columnIndex: i,\n        rowId: rowId,\n        minFirstColumnIndex: minFirstColumn,\n        maxLastColumnIndex: maxLastColumn,\n        columns: columns\n      });\n      if (cellProps.colSpan > 1) {\n        i += cellProps.colSpan - 1;\n      }\n    }\n  }, [calculateCellColSpan]);\n  var columnSpanningPublicApi = {\n    unstable_getCellColSpanInfo: getCellColSpanInfo\n  };\n  var columnSpanningPrivateApi = {\n    calculateColSpan: calculateColSpan\n  };\n  useGridApiMethod(apiRef, columnSpanningPublicApi, 'public');\n  useGridApiMethod(apiRef, columnSpanningPrivateApi, 'private');\n  var handleColumnReorderChange = React.useCallback(function () {\n    // `colSpan` needs to be recalculated after column reordering\n    lookup.current = {};\n  }, []);\n  useGridApiEventHandler(apiRef, 'columnOrderChange', handleColumnReorderChange);\n};","map":{"version":3,"names":["React","useGridApiMethod","useGridApiEventHandler","useGridColumnSpanning","apiRef","lookup","useRef","setCellColSpanInfo","useCallback","rowId","columnIndex","cellColSpanInfo","sizes","current","getCellColSpanInfo","_lookup$current$rowId","calculateCellColSpan","params","minFirstColumnIndex","maxLastColumnIndex","columns","columnsLength","length","column","colSpan","getCellParams","field","spannedByColSpan","cellProps","width","computedWidth","j","nextColumnIndex","nextColumn","rightVisibleCellIndex","Math","min","leftVisibleCellIndex","calculateColSpan","_ref","minFirstColumn","maxLastColumn","i","columnSpanningPublicApi","unstable_getCellColSpanInfo","columnSpanningPrivateApi","handleColumnReorderChange"],"sources":["C:/Users/Adit/Desktop/mern-stack-final/frontend/node_modules/@mui/x-data-grid/hooks/features/columns/useGridColumnSpanning.js"],"sourcesContent":["import * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\n/**\n * @requires useGridColumns (method, event)\n * @requires useGridParamsApi (method)\n */\nexport const useGridColumnSpanning = apiRef => {\n  const lookup = React.useRef({});\n  const setCellColSpanInfo = React.useCallback((rowId, columnIndex, cellColSpanInfo) => {\n    const sizes = lookup.current;\n    if (!sizes[rowId]) {\n      sizes[rowId] = {};\n    }\n    sizes[rowId][columnIndex] = cellColSpanInfo;\n  }, []);\n  const getCellColSpanInfo = React.useCallback((rowId, columnIndex) => {\n    var _lookup$current$rowId;\n    return (_lookup$current$rowId = lookup.current[rowId]) == null ? void 0 : _lookup$current$rowId[columnIndex];\n  }, []);\n\n  // Calculate `colSpan` for the cell.\n  const calculateCellColSpan = React.useCallback(params => {\n    const {\n      columnIndex,\n      rowId,\n      minFirstColumnIndex,\n      maxLastColumnIndex,\n      columns\n    } = params;\n    const columnsLength = columns.length;\n    const column = columns[columnIndex];\n    const colSpan = typeof column.colSpan === 'function' ? column.colSpan(apiRef.current.getCellParams(rowId, column.field)) : column.colSpan;\n    if (!colSpan || colSpan === 1) {\n      setCellColSpanInfo(rowId, columnIndex, {\n        spannedByColSpan: false,\n        cellProps: {\n          colSpan: 1,\n          width: column.computedWidth\n        }\n      });\n      return {\n        colSpan: 1\n      };\n    }\n    let width = column.computedWidth;\n    for (let j = 1; j < colSpan; j += 1) {\n      const nextColumnIndex = columnIndex + j;\n      // Cells should be spanned only within their column section (left-pinned, right-pinned and unpinned).\n      if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {\n        const nextColumn = columns[nextColumnIndex];\n        width += nextColumn.computedWidth;\n        setCellColSpanInfo(rowId, columnIndex + j, {\n          spannedByColSpan: true,\n          rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),\n          leftVisibleCellIndex: columnIndex\n        });\n      }\n      setCellColSpanInfo(rowId, columnIndex, {\n        spannedByColSpan: false,\n        cellProps: {\n          colSpan,\n          width\n        }\n      });\n    }\n    return {\n      colSpan\n    };\n  }, [apiRef, setCellColSpanInfo]);\n\n  // Calculate `colSpan` for each cell in the row\n  const calculateColSpan = React.useCallback(({\n    rowId,\n    minFirstColumn,\n    maxLastColumn,\n    columns\n  }) => {\n    for (let i = minFirstColumn; i < maxLastColumn; i += 1) {\n      const cellProps = calculateCellColSpan({\n        columnIndex: i,\n        rowId,\n        minFirstColumnIndex: minFirstColumn,\n        maxLastColumnIndex: maxLastColumn,\n        columns\n      });\n      if (cellProps.colSpan > 1) {\n        i += cellProps.colSpan - 1;\n      }\n    }\n  }, [calculateCellColSpan]);\n  const columnSpanningPublicApi = {\n    unstable_getCellColSpanInfo: getCellColSpanInfo\n  };\n  const columnSpanningPrivateApi = {\n    calculateColSpan\n  };\n  useGridApiMethod(apiRef, columnSpanningPublicApi, 'public');\n  useGridApiMethod(apiRef, columnSpanningPrivateApi, 'private');\n  const handleColumnReorderChange = React.useCallback(() => {\n    // `colSpan` needs to be recalculated after column reordering\n    lookup.current = {};\n  }, []);\n  useGridApiEventHandler(apiRef, 'columnOrderChange', handleColumnReorderChange);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}